<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://haotrr.github.io</id>
    <title>Haotrr</title>
    <updated>2020-06-11T06:16:28.764Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://haotrr.github.io"/>
    <link rel="self" href="https://haotrr.github.io/atom.xml"/>
    <subtitle>A beautiful world you deserve.</subtitle>
    <logo>https://haotrr.github.io/images/avatar.png</logo>
    <icon>https://haotrr.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Haotrr</rights>
    <entry>
        <title type="html"><![CDATA[2018 与我]]></title>
        <id>https://haotrr.github.io/post/2018-and-me/</id>
        <link href="https://haotrr.github.io/post/2018-and-me/">
        </link>
        <updated>2018-12-31T15:00:40.000Z</updated>
        <summary type="html"><![CDATA[<p>感谢微博这一年来记录下了我的所思所想，今年用几条微博来回顾我的 2018。</p>
]]></summary>
        <content type="html"><![CDATA[<p>感谢微博这一年来记录下了我的所思所想，今年用几条微博来回顾我的 2018。</p>
<!-- more -->
<blockquote>
<p>感谢微博这一年来记录下了我的所思所想，今年用几条微博来回顾我的 2018。</p>
</blockquote>
<blockquote>
<p><a href="https://weibo.com/1762280947/FEAzlihp5">Anti-Enterprise，不要让大公司裹挟自己的生活。</a></p>
</blockquote>
<p>新年第一天，收到了坚果 Pro 2，那部漂亮得不像实力派的安卓手机。在受够了苹果对用户的傲慢之后，在 “F**k the Apple again and again” 之后，我决定放弃使用 iPhone，尝试回归 Andriod，一年下来，我发现自己失败了，我不出意外的话，我的下一部手机会是一部 iPhone，我发现自己暂时离不开苹果的生态。我们生活被那些大公司裹挟着，苹果、微信、淘宝、微博等等，我们越是挣扎着想要逃离它们，我们越是离不开它们，现代生活就是这样。</p>
<blockquote>
<p><a href="https://weibo.com/1762280947/G0FL40Z1X">早点回家买秋裤。</a></p>
</blockquote>
<p>那天，多年不穿秋裤的我，急匆匆地赶回家，只是为了上淘宝买秋裤。在那一瞬间，突然发现自己“老了”，开始向岁月屈服。另一件让自己感到可怕的是，有一段时间自己掉发很严重，幸亏赶紧给自己买了霸王洗发露，好好护理了一段时间，才保住了我本来就不浓密的头发。看来，随着年龄增长，我也开始慢慢有了自我保养的意识呢。</p>
<blockquote>
<p><a href="https://weibo.com/1762280947/G3qHrwhrB">一家人在广州。</a></p>
</blockquote>
<p>春节一家人在广州过的。在哪里过年不重要，重要的是家人能够团聚，能够开开心心的聊聊生活，畅谈一番未来。父母总是希望我和老哥能够安份下来，好好工作，然后结婚生子。可我总觉得那样的生活好无趣，我不知道自己是否做好了成为不孝子的觉悟，而眼下，我只能在有限的时间里面好好陪陪父母，并希望他们能够原谅自私的我。</p>
<blockquote>
<p><a href="https://weibo.com/1762280947/G488B1Cvs">18 年上半年的工作任务：换份好工作。</a><br>
这是年初立的最大的 Flag，直到 9 月中旬，我才真正离开了上一家公司。而新公司入职是在 10 月中旬，中间的一个月，给自己放了一个长假，看书，逛展，刷剧，陪老哥到处玩儿，算得上人生一大幸事。然而这段时间也让我思考了很多：我到底想要成为什么样的人？以后的我能靠什么养活自己或者家人？自己是否有勇气去做自己想做的事情？我希望自己能在 30 岁之前想明白这些问题。</p>
</blockquote>
<blockquote>
<p><a href="https://weibo.com/1762280947/G8A89mllx">3.22</a></p>
</blockquote>
<p>3 月 22 日，整整55年后，The Beatles 披头士乐队音乐作品正式登陆中国。最开始用 QQ 音乐听，之后用 Apple Music 听，后来不知为什么 Apple Music 上也没法正常听披头士之后，我用网易云音乐比较多，虽然云村也没有披头士的版权。3 月 22 日凌晨，手机一直响个不停，但睡意太重，我没睁眼查看具体消息，早上起床，看到云音乐推的私信，口中爆出一连串卧槽，现在想起我那股兴奋劲，就像看科比又投进了一个只有他能投进的球一样。今年，对于一个披头士乐迷来说，是幸福的。</p>
<blockquote>
<p><a href="https://weibo.com/1762280947/GeFnmnLY7">2018/05/01 北京今日美术馆</a></p>
</blockquote>
<p>五一请了三天年假，合起来总共有八天的假期，于是策划了这次北京天津之旅。之前我去的最北方是西北甘肃，对于真正的北方，我一直想去看看。这次旅行，最主要的目的其实还是去看《The Beatles, Tomorrow》明日披头士世界巡回展。早早买了展览的联名 T 恤和帆布包，开开心心地在展馆里待一天，感到特别的满足。</p>
<blockquote>
<p><a href="https://weibo.com/1762280947/GnkeGAu71">又回家了</a></p>
</blockquote>
<p>去年冬天的两次回家，是因为两个堂哥结婚，这次夏天回家，则是奔丧。凌晨 2 点接到老哥打过来的电话，告诉我大伯婶过世了。迷迷糊糊地买好车票，安排好手头的工作，请好丧假，有迷迷糊糊地睡去，6 点起床赶高铁，回到家已经是晚上 8 点。大伯婶的去世，突然让我感到很害怕，死神的魔爪已经伸向我的父辈了。2018 年很多人离开了我们，让我想起教主那句感慨：先是我们认识的人。然后是我们身边的人。最后，是我们自己。</p>
<blockquote>
<p><a href="https://weibo.com/1762280947/GsDkzmb59">在想十一怎么过</a></p>
</blockquote>
<p>上大学之后，每年能与老哥相处的时间基本上只有过年那几天。虽然偶尔是微信或视频聊天，但一起吃饭睡觉聊天的机会确实不多。好几年前，老哥就一直念叨这要来上海转转，于是趁着老哥的十一假期和我的职业空档期，策划了这次十一之旅。也没什么特别的安排，就是在上海，杭州，苏州兜了一圈，看看展，逛逛公园，欣赏一下江南水乡，吃点江南的小吃，更多地时候还是聊天，聊工作，聊书籍，聊音乐，甚至聊聊艺术。偶尔这样，就挺好。</p>
<blockquote>
<p><a href="https://weibo.com/1762280947/GCNDc2ZrD">由俭入奢易，由奢入俭难，消费降级？不存在的。</a></p>
</blockquote>
<p>今年年轻人的话题中，消费降级算得上很热门的一个了。室友天天喊着要消费降级，喊出那句：以后超过 20 块的外卖我不点；同事们也时常感叹想买的东西都太贵。依照我的不成熟的看法，该买啥还是得买啥，我们努力工作不就是想要一个好的生活品质吗？不知从何时起，自己已经深深信奉那句：人生苦短，及时行乐。消费降级于我而言，是不存在的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[RabbitMQ 入门教程（六）- RPC]]></title>
        <id>https://haotrr.github.io/post/rabbitmq-tutorial-go-6/</id>
        <link href="https://haotrr.github.io/post/rabbitmq-tutorial-go-6/">
        </link>
        <updated>2018-09-29T08:05:45.000Z</updated>
        <summary type="html"><![CDATA[<p>本系列是 RabbitMQ 官方教程 Go 版本的中译版本，本文为第六篇，介绍如何使用 RabbitMQ 来构建一个 RPC 系统</p>
]]></summary>
        <content type="html"><![CDATA[<p>本系列是 RabbitMQ 官方教程 Go 版本的中译版本，本文为第六篇，介绍如何使用 RabbitMQ 来构建一个 RPC 系统</p>
<!-- more -->
<p><a href="http://www.rabbitmq.com/tutorial-six-go.html">教程六 原文地址: &quot;Remote procedure call（RPC）&quot;</a></p>
<p>在 <a href="/post/rabbitmq-tutorial-go-2/">教程二</a> 中我们已经掌握了如何使用工作队列在多个工作者中分发实时消费的任务。</p>
<p>但是如果我们需要运行一个在远程机器上的函数然后等待它的运行结果呢？这就需要不同的技术了，这种模式通常被称作远程过程调用（Remote Procedure Call）或者 RPC。</p>
<p>在本教程中，我们将使用 RabbitMQ 来构建一个 RPC 系统：包含一个客户端和一个可扩展的 RPC 服务器。目前我们手头上没有值得分发的实时消费的任务，所以我们创建一个伪造用于返回斐波纳契数字（Fibonacci Number）的 RPC 服务。</p>
<h3 id="回调队列">回调队列</h3>
<p>一般来说通过 RabbitMQ 来实现 RPC 是很简单的，客户端发送一个请求消息然后服务器返回一个响应消息。为了接收响应消息，我们需要在请求中增加一个回调（callback）队列地址。可以使用默认队列，我们一起来试一试：</p>
<pre><code class="language-go">q, err := ch.QueueDeclare(
  &quot;&quot;,    // name
  false, // durable
  false, // delete when usused
  true,  // exclusive
  false, // noWait
  nil,   // arguments
)

err = ch.Publish(
  &quot;&quot;,          // exchange
  &quot;rpc_queue&quot;, // routing key
  false,       // mandatory
  false,       // immediate
  amqp.Publishing{
    ContentType:   &quot;text/plain&quot;,
    CorrelationId: corrId,
    ReplyTo:       q.Name,
    Body:          []byte(strconv.Itoa(n)),
})
</code></pre>
<h3 id="message-properties">Message properties</h3>
<h3 id="关联-id">关联 ID</h3>
<p>在上面的方法中，我们对每一个 RPC 请求都创建了一个回调队列，这样做效率相对低下，幸好我们还有更好的方式 -- 对每一个客户只创建一个回调队列。</p>
<p>这样会造成一个新的问题，队列对接收到的响应消息属于哪一个请求并不清楚。这时就该轮到 correlation_id 派上用场了。对每个请求，我们都将关联 ID 设为唯一值，然后当我们从回调队列中接收一个消息时，我们将使用到这个属性，通过它，我们可以将响应消息匹配的请求。对于那些未知的关联 ID 值，我们只需简单地丢弃消息 -- 它们不属于我们发送的请求。</p>
<p>你也许会问，我们为什么应该忽略回调队列中那些未知的消息而不是抛出一个错误？这是因为在服务端有可能出现竟态条件（race condition）。尽管不太常见，RPC 服务在发送一个响应消息之后但在发送一个确认消息给求情之前有可能会死掉，如果这种情况发生，重启 RPC 服务会重新处理请求，这就是为什么我们序啊哟优雅地处理重复响应的原因，RPC 应该是完全幂等的。</p>
<h3 id="总结">总结</h3>
<figure data-type="image" tabindex="1"><img src="http://img-haotrr.test.upcdn.net/blog/6-1-overall.png" alt="6-1-overall" loading="lazy"></figure>
<p>我们的 RPC 看起来应该是这样子的：<br>
客户机一旦启动，他就创建一个唯一匿名的回调队列。<br>
对每一个 RPC 请求，客户端发送的消息都包含这两个属性：reply_to 用于设置回调队列；correlation_id 用于对每一个请求设置唯一值。<br>
请求被发送到 rpc_queue 队列中。<br>
RPC 工作者（服务器）从 rpc_queue 队列中等待请求，请求一旦出现，它便处理响应的工作并通过 reply_to 字段提供的队列返回一条包含结果的消息给客户端。<br>
客户端通过回调队列等待接收数据。一旦响应消息出现，它便检查其 correlation_id 属性，如果匹配请求上的值便返回响应消息给对应的应用。</p>
<h2 id="整合来看">整合来看</h2>
<p>斐波纳契函数：</p>
<pre><code class="language-golang">func fib(n int) int {
        if n == 0 {
                return 0
        } else if n == 1 {
                return 1
        } else {
                return fib(n-1) + fib(n-2)
        }
}
</code></pre>
<p>我们声明了一个斐波纳契函数，并假设正整数为合法输入。（不要指望它对大的整数有效，它有可能是最慢的递归实现了）。</p>
<p>RPC 服务器的代码如下：</p>
<pre><code class="language-go">package main

import (
        &quot;fmt&quot;
        &quot;log&quot;
        &quot;strconv&quot;

        &quot;github.com/streadway/amqp&quot;
)

func failOnError(err error, msg string) {
        if err != nil {
                log.Fatalf(&quot;%s: %s&quot;, msg, err)
                panic(fmt.Sprintf(&quot;%s: %s&quot;, msg, err))
        }
}

func fib(n int) int {
        if n == 0 {
                return 0
        } else if n == 1 {
                return 1
        } else {
                return fib(n-1) + fib(n-2)
        }
}

func main() {
        conn, err := amqp.Dial(&quot;amqp://guest:guest@localhost:5672/&quot;)
        failOnError(err, &quot;Failed to connect to RabbitMQ&quot;)
        defer conn.Close()

        ch, err := conn.Channel()
        failOnError(err, &quot;Failed to open a channel&quot;)
        defer ch.Close()

        q, err := ch.QueueDeclare(
                &quot;rpc_queue&quot;, // name
                false,       // durable
                false,       // delete when usused
                false,       // exclusive
                false,       // no-wait
                nil,         // arguments
        )
        failOnError(err, &quot;Failed to declare a queue&quot;)

        err = ch.Qos(
                1,     // prefetch count
                0,     // prefetch size
                false, // global
        )
        failOnError(err, &quot;Failed to set QoS&quot;)

        msgs, err := ch.Consume(
                q.Name, // queue
                &quot;&quot;,     // consumer
                false,  // auto-ack
                false,  // exclusive
                false,  // no-local
                false,  // no-wait
                nil,    // args
        )
        failOnError(err, &quot;Failed to register a consumer&quot;)

        forever := make(chan bool)

        go func() {
                for d := range msgs {
                        n, err := strconv.Atoi(string(d.Body))
                        failOnError(err, &quot;Failed to convert body to integer&quot;)

                        log.Printf(&quot; [.] fib(%d)&quot;, n)
                        response := fib(n)

                        err = ch.Publish(
                                &quot;&quot;,        // exchange
                                d.ReplyTo, // routing key
                                false,     // mandatory
                                false,     // immediate
                                amqp.Publishing{
                                        ContentType:   &quot;text/plain&quot;,
                                        CorrelationId: d.CorrelationId,
                                        Body:          []byte(strconv.Itoa(response)),
                                })
                        failOnError(err, &quot;Failed to publish a message&quot;)

                        d.Ack(false)
                }
        }()

        log.Printf(&quot; [*] Awaiting RPC requests&quot;)
        &lt;-forever
}
</code></pre>
<p>服务端代码相当明了：<br>
像之前那样我们从建立连接，创建信道和声明队列开始。<br>
我们也许想要运行多个服务进程，为了均衡每个服务器的负载，我们需要在信道上设置 prefetch 属性。<br>
我们使用 Channel.Consume 来获取 Go 中从队列中接收消息的信道。然后我们进入处理具体工作和返回响应的 gorountine。</p>
<p>RPC 客户端的代码如下：</p>
<pre><code class="language-go">package main

import (
        &quot;fmt&quot;
        &quot;log&quot;
        &quot;math/rand&quot;
        &quot;os&quot;
        &quot;strconv&quot;
        &quot;strings&quot;
        &quot;time&quot;

        &quot;github.com/streadway/amqp&quot;
)

func failOnError(err error, msg string) {
        if err != nil {
                log.Fatalf(&quot;%s: %s&quot;, msg, err)
                panic(fmt.Sprintf(&quot;%s: %s&quot;, msg, err))
        }
}

func randomString(l int) string {
        bytes := make([]byte, l)
        for i := 0; i &lt; l; i++ {
                bytes[i] = byte(randInt(65, 90))
        }
        return string(bytes)
}

func randInt(min int, max int) int {
        return min + rand.Intn(max-min)
}

func fibonacciRPC(n int) (res int, err error) {
        conn, err := amqp.Dial(&quot;amqp://guest:guest@localhost:5672/&quot;)
        failOnError(err, &quot;Failed to connect to RabbitMQ&quot;)
        defer conn.Close()

        ch, err := conn.Channel()
        failOnError(err, &quot;Failed to open a channel&quot;)
        defer ch.Close()

        q, err := ch.QueueDeclare(
                &quot;&quot;,    // name
                false, // durable
                false, // delete when usused
                true,  // exclusive
                false, // noWait
                nil,   // arguments
        )
        failOnError(err, &quot;Failed to declare a queue&quot;)

        msgs, err := ch.Consume(
                q.Name, // queue
                &quot;&quot;,     // consumer
                true,   // auto-ack
                false,  // exclusive
                false,  // no-local
                false,  // no-wait
                nil,    // args
        )
        failOnError(err, &quot;Failed to register a consumer&quot;)

        corrId := randomString(32)

        err = ch.Publish(
                &quot;&quot;,          // exchange
                &quot;rpc_queue&quot;, // routing key
                false,       // mandatory
                false,       // immediate
                amqp.Publishing{
                        ContentType:   &quot;text/plain&quot;,
                        CorrelationId: corrId,
                        ReplyTo:       q.Name,
                        Body:          []byte(strconv.Itoa(n)),
                })
        failOnError(err, &quot;Failed to publish a message&quot;)

        for d := range msgs {
                if corrId == d.CorrelationId {
                        res, err = strconv.Atoi(string(d.Body))
                        failOnError(err, &quot;Failed to convert body to integer&quot;)
                        break
                }
        }

        return
}

func main() {
        rand.Seed(time.Now().UTC().UnixNano())

        n := bodyFrom(os.Args)

        log.Printf(&quot; [x] Requesting fib(%d)&quot;, n)
        res, err := fibonacciRPC(n)
        failOnError(err, &quot;Failed to handle RPC request&quot;)

        log.Printf(&quot; [.] Got %d&quot;, res)
}

func bodyFrom(args []string) int {
        var s string
        if (len(args) &lt; 2) || os.Args[1] == &quot;&quot; {
                s = &quot;30&quot;
        } else {
                s = strings.Join(args[1:], &quot; &quot;)
        }
        n, err := strconv.Atoi(s)
        failOnError(err, &quot;Failed to convert arg to integer&quot;)
        return n
}
</code></pre>
<p>现在是时候好好看一看整个例子的源代码了： <a href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/go/rpc_server.go">rpc_server.go</a> 和 <a href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/go/rpc_client.go">rpc_client.go</a> 。</p>
<p>RPC 服务现在已经就位，我们可以开始运行：</p>
<pre><code class="language-sh">go run rpc_server.go
# =&gt; [x] Awaiting RPC requests
</code></pre>
<p>请求一个斐波纳契数字，运行客户端：</p>
<pre><code class="language-sh">go run rpc_client.go 30
# =&gt; [x] Requesting fib(30)
</code></pre>
<p>上面展示的程序不是 RPC 服务的唯一实现，但其有几个很重要的优势：</p>
<ul>
<li>如果 RPC 服务器太慢，可以通过增加另外一个服务实例来扩展，请尝试在新的终端运行第二个 rpc_server.go。</li>
<li>对于客户端，RPC 只需发送和接收一个消息，最终，RPC 客户端对每个 RPC 请求只需要一个网络循环。</li>
</ul>
<p>我们的代码仍然相当简单，但是不要试图用它来解决更加复杂（但很重要）的问题，比如：</p>
<ul>
<li>如果没有服务程序在运行，客户端该怎样反应？</li>
<li>RPC 客户端是否需要某种超时机制？</li>
<li>如果服务器失灵并且抛出异常，应该返回给客户端吗？</li>
<li>在处理接消息之前对其进行保护（如检查边界，类型等）以免处理了非法的信息。</li>
</ul>
<blockquote>
<p>如果想要更加深入地探究，你会发现 <a href="https://www.rabbitmq.com/management.html">management UI</a> 对查看队列非常有用。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[RabbitMQ 入门教程（五）- 主题交换机]]></title>
        <id>https://haotrr.github.io/post/rabbitmq-tutorial-go-5/</id>
        <link href="https://haotrr.github.io/post/rabbitmq-tutorial-go-5/">
        </link>
        <updated>2018-09-29T08:05:34.000Z</updated>
        <summary type="html"><![CDATA[<p>本系列是 RabbitMQ 官方教程 Go 版本的中译版本，本文为第五篇，介绍 RabbitMQ 中较复杂但非常实用的 topic 交换机。</p>
]]></summary>
        <content type="html"><![CDATA[<p>本系列是 RabbitMQ 官方教程 Go 版本的中译版本，本文为第五篇，介绍 RabbitMQ 中较复杂但非常实用的 topic 交换机。</p>
<!-- more -->
<p><a href="http://www.rabbitmq.com/tutorial-five-go.html">教程五 原文地址: &quot;Topics&quot;</a></p>
<p>在 <a href="/post/rabbitmq-tutorial-go-4/">教程四</a> 中我们改善了日志系统，为了伪造出广播功能，我们使用 direct 交换机来替换 fanout 交换机，同时我们获得了选择性接收日志的能力。</p>
<p>尽管使用 direct 交换机提升了我们的系统，但它仍有限制 -- 无法基于多个条件来路由。</p>
<p>在我们的日志系统中，我们可能不仅仅想要基于日志严重级别来，而且同时可以几乎发送日志的来源来订阅。你此前可能了解过同时基于日志严重级别（info/warn/crit..）和设备（auth/cron/kern...）的 Unix 工具 syslog。</p>
<p>这样能够给我们提供更多的灵活性 -- 我们也许只想要监听那些来之 cron 严重的错误日志和来自 kern 的所有日志。</p>
<p>为了实现这样的日志系统，我们需要了解更加复杂的 topic 交换机。</p>
<h2 id="topic-交换机">Topic 交换机</h2>
<p>发送至 topic 交换机的消息不是使用任意字符的 <code>routing_key</code> -- 而是必须是一串使用点符号（.）分隔的单词。这些单词可以是任何字符串，但通常描述了消息的某种特性，合理的路由规则如：“stock.usd.nyse”，“nyse.vmw”，“quick.orange.rabbit” 等等。可以在路由规则中使用任意多个单词，但每个单词的长度上限为 255 字节。</p>
<p>绑定规则必须与路由规则相同，因为 topic 交换机背后的逻辑和 direct 交换机背后的逻辑一样 -- 发送给交换机的带有特定路由规则的消息会被投递到所有与绑定规则匹配的队列中。然而，对绑定规则有如下两个特殊情况：</p>
<ul>
<li>（star）可以替代一个单词</li>
<li>（hash）可以替代零个或多个单词</li>
</ul>
<p>最好通过实例来解释：</p>
<figure data-type="image" tabindex="1"><img src="http://img-haotrr.test.upcdn.net/blog/5-1-overall.png" alt="5-1-overall" loading="lazy"></figure>
<p>在上面的例子中，我们发送的消息都是用于描述动物的，这些待发送的消息的路由规则都包含三个单词（两个点），路由规则的第一个单词描述速度，第二个描述颜色，第三个描述物种：“<speed>.<colour>.<species>”。</p>
<p>同时创建三个绑定：Q1 使用路由规则 <em>.orange.</em> 绑定，Q2 使用路由规则 <em>.</em>.rabbit 和 lazy.#。</p>
<p>这些绑定可以概括为：</p>
<ul>
<li>Q1 对所有橘色的动物的消息感兴趣</li>
<li>Q2 想要获取所有关于兔子的和所有跑得慢的动物的消息</li>
</ul>
<p>一个路由规则为 quick.orange.rabbit 的消息会被同时投递到两个队列中，路由规则为 lazy.orange.elephant 的消息也是一样。另一方面，路由规则为 quick.orange.fox 的消息会被投递到第一个队列中，路由规则为 lazy.brown.fox 的消息只会被投递到第二个队列中。路由规则为 lazy.pink.rabbit 的消息只会被投递到第二个队列中一次，尽管它同时匹配两个绑定。路由规则为 quick.brown.fox 不匹配任何绑定，所以会被丢弃。</p>
<p>如果我们打破上面的规则，发送路由规则为有一个或四个单词的诸如 orange 和 quick.orange.male.rabbit 这样的消息会怎样呢？情况是，这些消息不会被任何绑定匹配从而被丢弃。</p>
<p>另外一方面，路由规则为诸如 lazy.orange.male.rabbit 这样的消息尽管有四个单词，它仍然会匹配最后一个绑定从而被投递到第二个队列。</p>
<h2 id="note">note</h2>
<h2 id="整体来看">整体来看</h2>
<p>我们将在日志系统中使用 topic 交换机，并一开始就假设日志消息的路由规则包含两个单词：<facility>.<severity></p>
<p>代码几乎与上一篇教程一模一样。</p>
<p><code>emit_log_topic.go</code> 文件中的代码如下：</p>
<pre><code class="language-go">package main

import (
        &quot;fmt&quot;
        &quot;log&quot;
        &quot;os&quot;
        &quot;strings&quot;

        &quot;github.com/streadway/amqp&quot;
)

func failOnError(err error, msg string) {
        if err != nil {
                log.Fatalf(&quot;%s: %s&quot;, msg, err)
                panic(fmt.Sprintf(&quot;%s: %s&quot;, msg, err))
        }
}

func main() {
        conn, err := amqp.Dial(&quot;amqp://guest:guest@localhost:5672/&quot;)
        failOnError(err, &quot;Failed to connect to RabbitMQ&quot;)
        defer conn.Close()

        ch, err := conn.Channel()
        failOnError(err, &quot;Failed to open a channel&quot;)
        defer ch.Close()

        err = ch.ExchangeDeclare(
                &quot;logs_topic&quot;, // name
                &quot;topic&quot;,      // type
                true,         // durable
                false,        // auto-deleted
                false,        // internal
                false,        // no-wait
                nil,          // arguments
        )
        failOnError(err, &quot;Failed to declare an exchange&quot;)

        body := bodyFrom(os.Args)
        err = ch.Publish(
                &quot;logs_topic&quot;,          // exchange
                severityFrom(os.Args), // routing key
                false, // mandatory
                false, // immediate
                amqp.Publishing{
                        ContentType: &quot;text/plain&quot;,
                        Body:        []byte(body),
                })
        failOnError(err, &quot;Failed to publish a message&quot;)

        log.Printf(&quot; [x] Sent %s&quot;, body)
}

func bodyFrom(args []string) string {
        var s string
        if (len(args) &lt; 3) || os.Args[2] == &quot;&quot; {
                s = &quot;hello&quot;
        } else {
                s = strings.Join(args[2:], &quot; &quot;)
        }
        return s
}

func severityFrom(args []string) string {
        var s string
        if (len(args) &lt; 2) || os.Args[1] == &quot;&quot; {
                s = &quot;anonymous.info&quot;
        } else {
                s = os.Args[1]
        }
        return s
}
</code></pre>
<p><code>receive_logs_topic.go</code> 文件中的代码：</p>
<pre><code class="language-go">package main

import (
        &quot;fmt&quot;
        &quot;log&quot;
        &quot;os&quot;

        &quot;github.com/streadway/amqp&quot;
)

func failOnError(err error, msg string) {
        if err != nil {
                log.Fatalf(&quot;%s: %s&quot;, msg, err)
                panic(fmt.Sprintf(&quot;%s: %s&quot;, msg, err))
        }
}

func main() {
        conn, err := amqp.Dial(&quot;amqp://guest:guest@localhost:5672/&quot;)
        failOnError(err, &quot;Failed to connect to RabbitMQ&quot;)
        defer conn.Close()

        ch, err := conn.Channel()
        failOnError(err, &quot;Failed to open a channel&quot;)
        defer ch.Close()

        err = ch.ExchangeDeclare(
                &quot;logs_topic&quot;, // name
                &quot;topic&quot;,      // type
                true,         // durable
                false,        // auto-deleted
                false,        // internal
                false,        // no-wait
                nil,          // arguments
        )
        failOnError(err, &quot;Failed to declare an exchange&quot;)

        q, err := ch.QueueDeclare(
                &quot;&quot;,    // name
                false, // durable
                false, // delete when usused
                true,  // exclusive
                false, // no-wait
                nil,   // arguments
        )
        failOnError(err, &quot;Failed to declare a queue&quot;)

        if len(os.Args) &lt; 2 {
                log.Printf(&quot;Usage: %s [binding_key]...&quot;, os.Args[0])
                os.Exit(0)
        }
        for _, s := range os.Args[1:] {
                log.Printf(&quot;Binding queue %s to exchange %s with routing key %s&quot;,
                        q.Name, &quot;logs_topic&quot;, s)
                err = ch.QueueBind(
                        q.Name,       // queue name
                        s,            // routing key
                        &quot;logs_topic&quot;, // exchange
                        false,
                        nil)
                failOnError(err, &quot;Failed to bind a queue&quot;)
        }

        msgs, err := ch.Consume(
                q.Name, // queue
                &quot;&quot;,     // consumer
                true,   // auto ack
                false,  // exclusive
                false,  // no local
                false,  // no wait
                nil,    // args
        )
        failOnError(err, &quot;Failed to register a consumer&quot;)

        forever := make(chan bool)

        go func() {
                for d := range msgs {
                        log.Printf(&quot; [x] %s&quot;, d.Body)
                }
        }()

        log.Printf(&quot; [*] Waiting for logs. To exit press CTRL+C&quot;)
        &lt;-forever
}
</code></pre>
<p>接收所有日志：</p>
<pre><code class="language-sh">go run receive_logs_topic.go &quot;#&quot;
</code></pre>
<p>从 kern 设备接收所有日志：</p>
<pre><code class="language-sh">go run receive_logs_topic.go &quot;kern.*&quot;
</code></pre>
<p>或者只想要接收严重级别（critical）的日志：</p>
<pre><code class="language-sh">go run receive_logs_topic.go &quot;*.critical&quot;
</code></pre>
<p>也可以创建多个绑定：</p>
<pre><code class="language-sh">go run receive_logs_topic.go &quot;kern.*&quot; &quot;*.critical&quot;
</code></pre>
<p>发送一条如有规则为 kern.critical 的消息：</p>
<pre><code class="language-sh">go run emit_log_topic.go &quot;kern.critical&quot; &quot;A critical kernel error&quot;
</code></pre>
<p>请尽情地探究这些程序的玩法。既然代码中并没有对路由规则或绑定规则做任何假设，你可以尝试使用超过两个以上的路由规则参数。</p>
<p>完整的代码文件参见 <a href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/go/emit_log_topic.go">emit_log_topic.go</a> 和 <a href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/go/receive_logs_topic.go">receive_logs_topic.go</a></p>
<p>下一步，在 <a href="/post/rabbitmq-tutorial-go-6/">教程六</a> 中我们将探究发送作为远程调用过程的循环消息。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[RabbitMQ 入门教程（四）- 路由绑定]]></title>
        <id>https://haotrr.github.io/post/rabbitmq-tutorial-go-4/</id>
        <link href="https://haotrr.github.io/post/rabbitmq-tutorial-go-4/">
        </link>
        <updated>2018-09-29T08:05:24.000Z</updated>
        <summary type="html"><![CDATA[<p>本系列是 RabbitMQ 官方教程 Go 版本的中译版本，本文为第四篇，介绍如何对 RabbitMQ 进行路由绑定。</p>
]]></summary>
        <content type="html"><![CDATA[<p>本系列是 RabbitMQ 官方教程 Go 版本的中译版本，本文为第四篇，介绍如何对 RabbitMQ 进行路由绑定。</p>
<!-- more -->
<p><a href="http://www.rabbitmq.com/tutorial-four-go.html">教程四 原文地址: &quot;Routing&quot;</a></p>
<p>在 <a href="/post/rabbitmq-tutorial-go-3/">教程三</a> 中我们构建了一个简单的日志系统，我们可以将日志信息广播给很多接受者。</p>
<p>本教程中，我们将向这个日志系统增加一些新的功能，使接受者能够只订阅部分的日志信息。比如，我们可以只将错误日志信息保存到文件（磁盘空间），同时将所有的日志信息打印到终端。</p>
<h2 id="绑定">绑定</h2>
<p>上一教程中，我们已经创建了绑定，让我们先来回顾相关代码：</p>
<pre><code class="language-go">err = ch.QueueBind(
  q.Name, // queue name
  &quot;&quot;,     // routing key
  &quot;logs&quot;, // exchange
  false,
  nil)
</code></pre>
<p>一个绑定是一个交换机和一个队列的相互关联，简单说就是：一个队列对某个交换机上的信息感兴趣。</p>
<p>绑定有一个名为 <code>routing_key</code> 的参数，为了避免与 <code>Channel.Publish</code> 中的参数相混淆，我们将其成为绑定规则（<code>binding key</code>），下面的代码演示了怎样使用绑定规则创建一个绑定。</p>
<pre><code class="language-go">err = ch.QueueBind(
  q.Name,    // queue name
  &quot;black&quot;,   // routing key
  &quot;logs&quot;,    // exchange
  false,
  nil)
</code></pre>
<p>绑定规则的意义取决于交换机类型。在之前的 fanout 交换机中，我们直接忽略了这个参数值。</p>
<h2 id="direct-交换机">Direct 交换机</h2>
<p>在上一篇教程中，我们的日志系统将所有消息广播给所有消费者，现在，我们通过扩展上例来允许我们根据日志的严重程度来筛选日志信息。比如，我们可能想要将日志使写入磁盘的程序只接收严格错误日志，从而不会浪费空间来储存警告或通知级别的日志信息。</p>
<p>我们之前使用的是 fanout 交换机，但其灵活性不高 -- 它只会做无脑的广播操作。</p>
<p>我们将使用 direct 交换机来替代。Direct 交换机背后的路由算法很简单 -- 消息将会进入与其 <code>routing key</code> 匹配到的 <code>binding key</code> 的队列。</p>
<p>为了演示上述算法，请看下面的图示：</p>
<figure data-type="image" tabindex="1"><img src="http://img-haotrr.test.upcdn.net/blog/4-1-direct-exchange.png" alt="4-1-direct-exchange" loading="lazy"></figure>
<p>图示中，我们可以看到有两个队列绑定到了 direct 交换机 X 上，第一个队列使用路由规则 orange 绑定；第二个队列则有连个绑定，一个绑定规则为 black，另一个为 green。</p>
<p>图示中，发布到交换机的消息中，带有路由规则 orange 被路由到了队列 Q1，带有路由规则 black 或 green 的则被路由到队列 Q2，其它的消息则会被丢弃。</p>
<h2 id="多重绑定">多重绑定</h2>
<figure data-type="image" tabindex="2"><img src="http://img-haotrr.test.upcdn.net/blog/4-2-direct-exchange-multiple.png" alt="4-2-direct-exchange-multiple" loading="lazy"></figure>
<p>使用相同的路由规则绑定多个队列完全是合法的，上面的图示中，我们使用路由规则 black 往 X 上增加了一个与 Q1 的绑定，这样，direct 交换机就像 fanout 交换机一样回报消息广播给所有匹配的队列：一个带有路由规则 black 的消息会被同时投递到 Q1 和 Q2 上。</p>
<h2 id="发送日志">发送日志</h2>
<p>我们使用上述的模型来重构日志系统，使用 direct 交换机来替换原先的 fanout 交换机来发送消息。我们始于哦能够日志严重级别来作为路由规则，这样我们的接收程序就可以选择它想要接收的日志。我们先来关注日志的发送。</p>
<p>像之前一样，我们首先需要创建一个交换机：</p>
<pre><code class="language-go">err = ch.ExchangeDeclare(
  &quot;logs_direct&quot;, // name
  &quot;direct&quot;,      // type
  true,          // durable
  false,         // auto-deleted
  false,         // internal
  false,         // no-wait
  nil,           // arguments
)
</code></pre>
<p>然后我们就可以发送消息了：</p>
<pre><code class="language-go">err = ch.ExchangeDeclare(
  &quot;logs_direct&quot;, // name
  &quot;direct&quot;,      // type
  true,          // durable
  false,         // auto-deleted
  false,         // internal
  false,         // no-wait
  nil,           // arguments
)
failOnError(err, &quot;Failed to declare an exchange&quot;)

body := bodyFrom(os.Args)
err = ch.Publish(
  &quot;logs_direct&quot;,         // exchange
  severityFrom(os.Args), // routing key
  false, // mandatory
  false, // immediate
  amqp.Publishing{
    ContentType: &quot;text/plain&quot;,
    Body:        []byte(body),
})
</code></pre>
<p>为了简化操作我们假设日志严重级别分为：info、warning 和 error。</p>
<h2 id="订阅">订阅</h2>
<p>接收消息的操作与上一教程中相似，除了一点 -- 我们要为每一个我们在意的日志严重级别创建一个绑定。</p>
<pre><code class="language-go">q, err := ch.QueueDeclare(
  &quot;&quot;,    // name
  false, // durable
  false, // delete when usused
  true,  // exclusive
  false, // no-wait
  nil,   // arguments
)
failOnError(err, &quot;Failed to declare a queue&quot;)

if len(os.Args) &lt; 2 {
  log.Printf(&quot;Usage: %s [info] [warning] [error]&quot;, os.Args[0])
  os.Exit(0)
}
for _, s := range os.Args[1:] {
  log.Printf(&quot;Binding queue %s to exchange %s with routing key %s&quot;,
     q.Name, &quot;logs_direct&quot;, s)
  err = ch.QueueBind(
    q.Name,        // queue name
    s,             // routing key
    &quot;logs_direct&quot;, // exchange
    false,
    nil)
  failOnError(err, &quot;Failed to bind a queue&quot;)
}
</code></pre>
<h2 id="整体来看">整体来看</h2>
<figure data-type="image" tabindex="3"><img src="http://img-haotrr.test.upcdn.net/blog/4-3-overall.png" alt="4-3-overall" loading="lazy"></figure>
<p><code>emit_log_direct.go</code> 文件内容：</p>
<pre><code class="language-go">package main

import (
        &quot;fmt&quot;
        &quot;log&quot;
        &quot;os&quot;
        &quot;strings&quot;

        &quot;github.com/streadway/amqp&quot;
)

func failOnError(err error, msg string) {
        if err != nil {
                log.Fatalf(&quot;%s: %s&quot;, msg, err)
                panic(fmt.Sprintf(&quot;%s: %s&quot;, msg, err))
        }
}

func main() {
        conn, err := amqp.Dial(&quot;amqp://guest:guest@localhost:5672/&quot;)
        failOnError(err, &quot;Failed to connect to RabbitMQ&quot;)
        defer conn.Close()

        ch, err := conn.Channel()
        failOnError(err, &quot;Failed to open a channel&quot;)
        defer ch.Close()

        err = ch.ExchangeDeclare(
                &quot;logs_direct&quot;, // name
                &quot;direct&quot;,      // type
                true,          // durable
                false,         // auto-deleted
                false,         // internal
                false,         // no-wait
                nil,           // arguments
        )
        failOnError(err, &quot;Failed to declare an exchange&quot;)

        body := bodyFrom(os.Args)
        err = ch.Publish(
                &quot;logs_direct&quot;,         // exchange
                severityFrom(os.Args), // routing key
                false, // mandatory
                false, // immediate
                amqp.Publishing{
                        ContentType: &quot;text/plain&quot;,
                        Body:        []byte(body),
                })
        failOnError(err, &quot;Failed to publish a message&quot;)

        log.Printf(&quot; [x] Sent %s&quot;, body)
}

func bodyFrom(args []string) string {
        var s string
        if (len(args) &lt; 3) || os.Args[2] == &quot;&quot; {
                s = &quot;hello&quot;
        } else {
                s = strings.Join(args[2:], &quot; &quot;)
        }
        return s
}

func severityFrom(args []string) string {
        var s string
        if (len(args) &lt; 2) || os.Args[1] == &quot;&quot; {
                s = &quot;info&quot;
        } else {
                s = os.Args[1]
        }
        return s
}
</code></pre>
<p><code>receive_log_direct.go</code> 文件内容：</p>
<pre><code class="language-go">package main

import (
        &quot;fmt&quot;
        &quot;log&quot;
        &quot;os&quot;

        &quot;github.com/streadway/amqp&quot;
)

func failOnError(err error, msg string) {
        if err != nil {
                log.Fatalf(&quot;%s: %s&quot;, msg, err)
                panic(fmt.Sprintf(&quot;%s: %s&quot;, msg, err))
        }
}

func main() {
        conn, err := amqp.Dial(&quot;amqp://guest:guest@localhost:5672/&quot;)
        failOnError(err, &quot;Failed to connect to RabbitMQ&quot;)
        defer conn.Close()

        ch, err := conn.Channel()
        failOnError(err, &quot;Failed to open a channel&quot;)
        defer ch.Close()

        err = ch.ExchangeDeclare(
                &quot;logs_direct&quot;, // name
                &quot;direct&quot;,      // type
                true,          // durable
                false,         // auto-deleted
                false,         // internal
                false,         // no-wait
                nil,           // arguments
        )
        failOnError(err, &quot;Failed to declare an exchange&quot;)

        q, err := ch.QueueDeclare(
                &quot;&quot;,    // name
                false, // durable
                false, // delete when usused
                true,  // exclusive
                false, // no-wait
                nil,   // arguments
        )
        failOnError(err, &quot;Failed to declare a queue&quot;)

        if len(os.Args) &lt; 2 {
                log.Printf(&quot;Usage: %s [info] [warning] [error]&quot;, os.Args[0])
                os.Exit(0)
        }
        for _, s := range os.Args[1:] {
                log.Printf(&quot;Binding queue %s to exchange %s with routing key %s&quot;,
                        q.Name, &quot;logs_direct&quot;, s)
                err = ch.QueueBind(
                        q.Name,        // queue name
                        s,             // routing key
                        &quot;logs_direct&quot;, // exchange
                        false,
                        nil)
                failOnError(err, &quot;Failed to bind a queue&quot;)
        }

        msgs, err := ch.Consume(
                q.Name, // queue
                &quot;&quot;,     // consumer
                true,   // auto ack
                false,  // exclusive
                false,  // no local
                false,  // no wait
                nil,    // args
        )
        failOnError(err, &quot;Failed to register a consumer&quot;)

        forever := make(chan bool)

        go func() {
                for d := range msgs {
                        log.Printf(&quot; [x] %s&quot;, d.Body)
                }
        }()

        log.Printf(&quot; [*] Waiting for logs. To exit press CTRL+C&quot;)
        &lt;-forever
}
</code></pre>
<p>如果只想要将 warning 和 error（而不是 info）级别的日志消息保存至文件中，只需要打开终端并键入：</p>
<pre><code class="language-sh">go run receive_logs_direct.go warning error &gt; logs_from_rabbit.log
</code></pre>
<p>如果想要在屏幕中显示所有的日志消息，打开终端并输入：</p>
<pre><code class="language-sh">go run receive_logs_direct.go info warning error
# =&gt; [*] Waiting for logs. To exit press CTRL+C
</code></pre>
<p>如果只想要发送 error 级别的日志，只需要输入：</p>
<pre><code class="language-sh">go run emit_log_direct.go error &quot;Run. Run. Or it will explode.&quot;
# =&gt; [x] Sent 'error':'Run. Run. Or it will explode.'
</code></pre>
<p>完整的源代码参见：<a href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/go/emit_log_direct.go">emit_log_direct.go</a> 和 <a href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/go/receive_log_direct.go">receive_log_direct.go</a></p>
<p>请移步 <a href="/post/rabbitmq-tutorial-go-5/">教程五</a> 探究如何基于模式来监听消息。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[RabbitMQ 入门教程（三）- 发布订阅]]></title>
        <id>https://haotrr.github.io/post/rabbitmq-tutorial-go-3/</id>
        <link href="https://haotrr.github.io/post/rabbitmq-tutorial-go-3/">
        </link>
        <updated>2018-09-29T08:05:01.000Z</updated>
        <summary type="html"><![CDATA[<p>本系列是 RabbitMQ 官方教程 Go 版本的中译版本，本文为第三篇，介绍 RabbitMQ 的发布订阅模式。</p>
]]></summary>
        <content type="html"><![CDATA[<p>本系列是 RabbitMQ 官方教程 Go 版本的中译版本，本文为第三篇，介绍 RabbitMQ 的发布订阅模式。</p>
<!-- more -->
<p><a href="http://www.rabbitmq.com/tutorial-three-go.html">教程三 原文地址: &quot;Publish/Subscribe&quot;</a></p>
<p>在<a href="/post/rabbitmq-tutorial-go-2/">上一教程</a>中我们创建了工作队列，在工作队列中，每个任务假设被分发给唯一的工作者，本教程将处理完全不同的情况 -- 将一个消息同时分发给不同的消费者，这种模式被成为“发布/订阅”模式。</p>
<p>为了演示“发布/订阅”模式，我们将创建一个简单的日志系统，包含两个程序 -- 一个发送日志消息，一个用于接收日志消息并将之打印。</p>
<p>在我们的日志系统中，每一份接收程序的拷贝都会待应接收到的消息，这样我们就能够在运行一个用于接收并将日志写入磁盘的程序的同时，我们还可以运行一个用于接收并将日志打印到屏幕的程序。</p>
<p>本质上，发布日志消息就是将其广播给所有接受者。</p>
<h2 id="交换机">交换机</h2>
<p>在系列教程的前面部分，我们使用队列来发送和接收消息，现在，我们将介绍 RabbitMQ 中完整的消息模型。</p>
<p>先让我们快速地复习一下之前学习过的内容：</p>
<ul>
<li>一个生产者是一个用于发送消息的应用程序。</li>
<li>一个队列是一个用于存储消息的缓存。</li>
<li>一个消费者是一个用于接收消息的应用程序。</li>
</ul>
<p>RabbitMQ 中最核心的思想是：一个生成者永远不会向一个队列直接发送消息。实际上，一个消费者根本不需要知道一个消息是否将会投递到一个队列中。</p>
<p>相反，一个消费者只会将消息发送到交换机（exchange）上。交换机非常简单，一方面它从生成者那里接收消息，另一方面它将消息推送给队列。交换机必须明确地知道它将接收怎样的消息，消息将会被附加到特定的队列？消息将会被附加到很多队列？或者消息会被丢弃？这些规则将通过交换机类型（exchange type）定义。</p>
<figure data-type="image" tabindex="1"><img src="http://img-haotrr.test.upcdn.net/blog/3-1-exchanges.png" alt="3-1-exchanges" loading="lazy"></figure>
<p>RabbitMQ 提供了四种交换机：direct，topic，headers 和 fanout。我们主要关注最后一种 -- fanout。下面，让我们创建一个 fanout 类型的交换机，并命名为 <code>logs</code>：</p>
<pre><code class="language-go">err = ch.ExchangeDeclare(
  &quot;logs&quot;,   // name
  &quot;fanout&quot;, // type
  true,     // durable
  false,    // auto-deleted
  false,    // internal
  false,    // no-wait
  nil,      // arguments
)
</code></pre>
<p>fanout 类型的交换机非常简单，从名字就可推断出来，它将所有接收到的消息广播到它所知的所有队列上，这恰好就是我们日志系统所需要的。</p>
<blockquote>
<p>Note:</p>
<p><strong>列出所有交换机</strong></p>
<p>列出服务器上的交换机可以使用命令 <code>rabbitmqctl</code>:</p>
<pre><code class="language-sh">sudo rabbitmqctl list_exchangs
</code></pre>
</blockquote>
<p>现在，我们可以将消息发布到我们命名的交换机上：</p>
<pre><code class="language-go">err = ch.ExchangeDeclare(
  &quot;logs&quot;,   // name
  &quot;fanout&quot;, // type
  true,     // durable
  false,    // auto-deleted
  false,    // internal
  false,    // no-wait
  nil,      // arguments
)
failOnError(err, &quot;Failed to declare an exchange&quot;)

body := bodyFrom(os.Args)
err = ch.Publish(
  &quot;logs&quot;, // exchange
  &quot;&quot;,     // routing key
  false,  // mandatory
  false,  // immediate
  amqp.Publishing{
          ContentType: &quot;text/plain&quot;,
          Body:        []byte(body),
  })
</code></pre>
<h2 id="临时队列">临时队列</h2>
<p>你应该还记得我们之前使用的特定名字的队列（还记得 <code>hello</code> 和 <code>task_queue</code> 吗？），能够对队列进行命名相当重要 -- 我们需要将不同的工作者指向相同的队列。当在不同的生产者和消费者中共享同一个队列时给一个队列命名非常重要。</p>
<p>但对于我们的日志系统却并非如此，我们想要监控所有的日志消息，而不只是其中的部分，而且我们只对当前消息而不是旧的消息感兴趣，为了解决这个问题，我们需要做两件事情。</p>
<p>首先，每次我们连接到 RabbitMQ，我们都需要一个全新的、空的队列，我们可以创建一个随机命名的队列来实现，或者使用更好的方式 -- 让服务器来随机地为我们分配一个队列名字。</p>
<p>第二，一旦我们断开连接，队列自动删除。</p>
<p>在 <a href="http://godoc.org/github.com/streadway/amqp">amqp</a> 客户端中，当我们将队列名字设为一个空字符串时，我们就创建了一个随机命名的非持久化队列。</p>
<pre><code class="language-go">q, err := ch.QueueDeclare(
  &quot;&quot;,    // name
  false, // durable
  false, // delete when unused
  true,  // exclusive
  false, // no-wait
  nil,   // arguments
)
</code></pre>
<p><code>QueueDeclare</code> 方法返回时，RabbitMQ 生成了一个随机命名的队列实例，随机的名字与 <code>amq.gen-JzTY20BRgKO-HjmUJj0wLg</code> 类似。</p>
<p>当连接断开时，队列会被删除，因为它被声明为独有的（exclusive）。</p>
<p>可以访问 <a href="https://www.rabbitmq.com/queues.html">guide on queues</a> 来了解更多关于 <code>exclusive</code> 和其它的队列属性。</p>
<h2 id="绑定">绑定</h2>
<figure data-type="image" tabindex="2"><img src="http://img-haotrr.test.upcdn.net/blog/3-2-bindings.png" alt="3-2-bindings" loading="lazy"></figure>
<p>此前，我们已经创建了一个 fanout 类型的交换机和队列了，现在我们需要告诉交换机将消息发送给队列。交换机和队列的关系叫做绑定（binding）。</p>
<pre><code class="language-go">err = ch.QueueBind(
  q.Name, // queue name
  &quot;&quot;,     // routing key
  &quot;logs&quot;, // exchange
  false,
  nil
)
</code></pre>
<p>现在我们的 <code>log</code> 交换机将会把消息附加到我们声明的队列中。</p>
<h2 id="整体运行">整体运行</h2>
<figure data-type="image" tabindex="3"><img src="http://img-haotrr.test.upcdn.net/blog/3-3-overall.png" alt="3-3-overall" loading="lazy"></figure>
<p>用于发送日志的生产者程序与教程二中的程序并没有太大区别，最主要的改变就是我们将消费发布到了我们自己命名的 <code>logs</code> 交换机而不是未命名的交换机。我们本需要在发送时设置一个 <code>routingKey</code>，但 <code>fanout</code> 类型的交换机会忽略它。下面时完整的 <code>emit_log.go</code> 文件内容：</p>
<pre><code class="language-go">package main

import (
        &quot;fmt&quot;
        &quot;log&quot;
        &quot;os&quot;
        &quot;strings&quot;

        &quot;github.com/streadway/amqp&quot;
)

func failOnError(err error, msg string) {
        if err != nil {
                log.Fatalf(&quot;%s: %s&quot;, msg, err)
                panic(fmt.Sprintf(&quot;%s: %s&quot;, msg, err))
        }
}

func main() {
        conn, err := amqp.Dial(&quot;amqp://guest:guest@localhost:5672/&quot;)
        failOnError(err, &quot;Failed to connect to RabbitMQ&quot;)
        defer conn.Close()

        ch, err := conn.Channel()
        failOnError(err, &quot;Failed to open a channel&quot;)
        defer ch.Close()

        err = ch.ExchangeDeclare(
                &quot;logs&quot;,   // name
                &quot;fanout&quot;, // type
                true,     // durable
                false,    // auto-deleted
                false,    // internal
                false,    // no-wait
                nil,      // arguments
        )
        failOnError(err, &quot;Failed to declare an exchange&quot;)

        body := bodyFrom(os.Args)
        err = ch.Publish(
                &quot;logs&quot;, // exchange
                &quot;&quot;,     // routing key
                false,  // mandatory
                false,  // immediate
                amqp.Publishing{
                        ContentType: &quot;text/plain&quot;,
                        Body:        []byte(body),
                })
        failOnError(err, &quot;Failed to publish a message&quot;)

        log.Printf(&quot; [x] Sent %s&quot;, body)
}

func bodyFrom(args []string) string {
        var s string
        if (len(args) &lt; 2) || os.Args[1] == &quot;&quot; {
                s = &quot;hello&quot;
        } else {
                s = strings.Join(args[1:], &quot; &quot;)
        }
        return s
}
</code></pre>
<p><a href="http://github.com/rabbitmq/rabbitmq-tutorials/blob/master/go/emit_log.go">emit_log.og</a></p>
<p>建立连接之后，我们声明了一个交换机，这一步是必须的，如果向一个不存在的交换机发布消息是被禁止的。</p>
<p>如果没有给交换机绑定队列，消息将会丢失，但对我们来说是 OK 的，如果没有消费者监听，我们可以简单地将消息丢弃。</p>
<p><code>receive_logs.go</code> 的代码如下：</p>
<pre><code class="language-go">package main

import (
        &quot;fmt&quot;
        &quot;log&quot;

        &quot;github.com/streadway/amqp&quot;
)

func failOnError(err error, msg string) {
        if err != nil {
                log.Fatalf(&quot;%s: %s&quot;, msg, err)
                panic(fmt.Sprintf(&quot;%s: %s&quot;, msg, err))
        }
}

func main() {
        conn, err := amqp.Dial(&quot;amqp://guest:guest@localhost:5672/&quot;)
        failOnError(err, &quot;Failed to connect to RabbitMQ&quot;)
        defer conn.Close()

        ch, err := conn.Channel()
        failOnError(err, &quot;Failed to open a channel&quot;)
        defer ch.Close()

        err = ch.ExchangeDeclare(
                &quot;logs&quot;,   // name
                &quot;fanout&quot;, // type
                true,     // durable
                false,    // auto-deleted
                false,    // internal
                false,    // no-wait
                nil,      // arguments
        )
        failOnError(err, &quot;Failed to declare an exchange&quot;)

        q, err := ch.QueueDeclare(
                &quot;&quot;,    // name
                false, // durable
                false, // delete when usused
                true,  // exclusive
                false, // no-wait
                nil,   // arguments
        )
        failOnError(err, &quot;Failed to declare a queue&quot;)

        err = ch.QueueBind(
                q.Name, // queue name
                &quot;&quot;,     // routing key
                &quot;logs&quot;, // exchange
                false,
                nil)
        failOnError(err, &quot;Failed to bind a queue&quot;)

        msgs, err := ch.Consume(
                q.Name, // queue
                &quot;&quot;,     // consumer
                true,   // auto-ack
                false,  // exclusive
                false,  // no-local
                false,  // no-wait
                nil,    // args
        )
        failOnError(err, &quot;Failed to register a consumer&quot;)

        forever := make(chan bool)

        go func() {
                for d := range msgs {
                        log.Printf(&quot; [x] %s&quot;, d.Body)
                }
        }()

        log.Printf(&quot; [*] Waiting for logs. To exit press CTRL+C&quot;)
        &lt;-forever
}
</code></pre>
<p><a href="http://github.com/rabbitmq/rabbitmq-tutorials/blob/master/go/receive_logs.go">receive_logs.go</a></p>
<p>如果想要将日志写入文件，运行以下命令：</p>
<pre><code class="language-sh">go run receive_logs.go &gt; logs_from_rabbit.log
</code></pre>
<p>想要在屏幕上查看日志，打开新的终端并运行：</p>
<pre><code class="language-sh">go run receive_logs.go
</code></pre>
<p>当然，发送日志需要运行：</p>
<pre><code class="language-sh">go run emit_log.go
</code></pre>
<p>通过运行 <code>rabbitmqctl list_bindings</code> 可以验证我们的代码确实创建了我们想要绑定和队列。通过运行两个 <code>receive_logs.go</code> 可以看到类似如下的输出内容：</p>
<pre><code class="language-sh">sudo rabbitmqctl list_bindings
# =&gt; Listing bindings ...
# =&gt; logs    exchange        amq.gen-JzTY20BRgKO-HjmUJj0wLg  queue           []
# =&gt; logs    exchange        amq.gen-vso0PVvyiRIL2WoV3i48Yg  queue           []
# =&gt; ...done.
</code></pre>
<p>上述的打印信息非常明显：数据从 <code>logs</code> 交换机流向了有服务器命名的两个队列，这正是我们想要的。</p>
<p>探究如何监听部分消息，请移步至 <a href="/post/rabbitmq-tutorial-go-4/">教程四</a>。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[RabbitMQ 入门教程（二）- 工作队列]]></title>
        <id>https://haotrr.github.io/post/rabbitmq-tutorial-go-2/</id>
        <link href="https://haotrr.github.io/post/rabbitmq-tutorial-go-2/">
        </link>
        <updated>2018-09-29T07:41:27.000Z</updated>
        <summary type="html"><![CDATA[<p>本系列是 RabbitMQ 官方教程 Go 版本的中译版本，本文为第二篇，介绍如何将 RabbitMQ 作为工作队列使用。</p>
]]></summary>
        <content type="html"><![CDATA[<p>本系列是 RabbitMQ 官方教程 Go 版本的中译版本，本文为第二篇，介绍如何将 RabbitMQ 作为工作队列使用。</p>
<!-- more -->
<p><a href="http://www.rabbitmq.com/tutorial-two-go.html">教程二 原文地址: &quot;Work Queues&quot;</a></p>
<p>在 <a href="/post/rabbitmq-tutorial-go-1/">教程一</a> 中我们编写了一个从命名的队列中发送和读取消息的程序，在本教程中，我们将创建一个用于分发被多个工作者（worker）实时消费的工作队列（Work Queue）。</p>
<p>工作队列（又名任务队列）背后的主要思想是：避免立即处理一个资源集中型的任务并等到它完成为止，而是将其延后处理。我们将一个消息封装成一个任务（task）并将其发送到队列中，一个后台运行的工作线程（worker process）会从队列头部依次取出任务并执行相关操作。如果同时运行多个工作线程，则不同的任务会被分配到不同的工作线程中。</p>
<p>这个概念在那些通过短连接的 HTTP 请求处理复杂任务的 Web 应用程序中尤其有用。</p>
<h2 id="准备">准备</h2>
<p>在本系列教程的教程一中，我们发送了一个包含&quot;Hello World!&quot;的消息，现在我们将发送代表复杂任务的字符串。本教程中，我们没有像图片大小调整或渲染 PDF 文件这样的真实任务，所以，我们通过使用 <code>time.Sleep</code> 函数伪造任务来假装很忙。我们使用字符串中点（dot）的个数来表示任务的复杂程度，每一个点将花费工作者一秒钟的时间，比如，一个由字符串 <code>Hello...</code> 伪造的任务将花费 3 秒钟的时间。</p>
<p>我们将稍稍改造前例中的 <code>send.go</code> 文件中的代码，从而让我们可以通过命令行来发送任意内容的消息。这个程序将任务调度到我们的工作队列中，我们将其命名为 <code>new_task.go</code> ：</p>
<pre><code class="language-go">body := bodyFrom(os.Args)
err = ch.Publish(
  &quot;&quot;,           // exchange
  q.Name,       // routing key
  false,        // mandatory
  false,
  amqp.Publishing {
    DeliveryMode: amqp.Persistent,
    ContentType:  &quot;text/plain&quot;,
    Body:         []byte(body),
  })
failOnError(err, &quot;Failed to publish a message&quot;)
log.Printf(&quot; [x] Sent %s&quot;, body)
</code></pre>
<p>旧的 <code>receive.go</code> 文件同样需要调整：它需要伪造以秒为单位处理消息中每个点的工作任务，它需要从工作队列中依次取出消息并处理相应的工作，所以我们将其命名为 <code>worker.go</code> ：</p>
<pre><code class="language-go">msgs, err := ch.Consume(
  q.Name, // queue
  &quot;&quot;,     // consumer
  true,   // auto-ack
  false,  // exclusive
  false,  // no-local
  false,  // no-wait
  nil,    // args
)
failOnError(err, &quot;Failed to register a consumer&quot;)

forever := make(chan bool)

go func() {
  for d := range msgs {
    log.Printf(&quot;Received a message: %s&quot;, d.Body)
    dot_count := bytes.Count(d.Body, []byte(&quot;.&quot;))
    t := time.Duration(dot_count)
    time.Sleep(t * time.Second)
    log.Printf(&quot;Done&quot;)
  }
}()

log.Printf(&quot; [*] Waiting for messages. To exit press CTRL+C&quot;)
&lt;-forever
</code></pre>
<p>注意，我们的伪造任务模拟了执行时间。</p>
<p>运行操作如下：</p>
<pre><code class="language-sh"># shell 1
go run worker.go
</code></pre>
<pre><code class="language-sh"># shell 2
go run worker.go
</code></pre>
<h2 id="轮询分发">轮询分发</h2>
<p>任务队列的优势之一是它很容易地将任务平行分发。假设我们正在处理一个将积压的工作，我们可以简单地通过增加更多的工作者（worker）来解决它，扩展起来就是这么简单。</p>
<p>首先，我们同时运行两个 <code>work.go</code>，它们将同时从队列中获取消息，但具体如何获取呢？我们拭目以待。</p>
<p>你需要打开三个终端，其中两个运行 <code>worker.go</code>，这两个终端将作为我们的消费者 -- 用 C1 和 C2 表示。</p>
<pre><code class="language-sh"># shell 1
go run worker.go
# =&gt; [*] Waiting for messages. To exit press CTRL+C
</code></pre>
<pre><code class="language-sh"># shell 2
go run worker.go
# =&gt; [*] Waiting for messages. To exit press CTRL+C
</code></pre>
<p>在第三个终端中，我们发布新的任务。一旦你运行了消费者之后，你就可以发送一些消息了：</p>
<pre><code class="language-sh"># shell 3
go run new_task.go First message.
go run new_task.go Second message..
go run new_task.go Third message...
go run new_task.go Fourth message....
go run new_task.go Fifth message.....
</code></pre>
<p>让我们来看看发送到消费者信息是什么：</p>
<pre><code class="language-sh"># shell 1
go run worker.go
# =&gt; [*] Waiting for messages. To exit press CTRL+C
# =&gt; [x] Received 'First message.'
# =&gt; [x] Received 'Third message...'
# =&gt; [x] Received 'Fifth message.....'
</code></pre>
<pre><code class="language-sh"># shell 2
go run worker.go
# =&gt; [*] Waiting for messages. To exit press CTRL+C
# =&gt; [x] Received 'Second message..'
# =&gt; [x] Received 'Fourth message....'
</code></pre>
<p>默认情况下，RabbitMQ 将顺序的把每个消息发送给下一个消费者。每个消费者将平均的获得相同数目的消息，这种分发消息的机制叫做轮询分发（round-robin）。可以尝试使用三个或更多的工作者来验证一下。</p>
<h2 id="消息确认">消息确认</h2>
<p>处理任务需要花费几秒钟的时间，你或许对一个消费者处理一个长时间的任务但只处理了一部分时就终止的情况会怎样感到好奇。在我们目前的代码中，一旦 RabbitMQ 发送了一个消息给消费者，它就立即将这个消息标记为删除。这种情况下，如果终止相应的工作者的话，我们将丢失它正在处理的那条消息，同时，我们还会丢失所有分发给这个工作者的尚未处理的消息。</p>
<p>实际工作中，我们不想丢失任何任务，如果一个工作者被终止，我们希望任务将被分发到另一个工作者。</p>
<p>为了确保一条消息永不丢失，RabbitMQ 支持<a href="https://www.rabbitmq.com/confirms.html">消息确认</a>。一个 ack（nowledgement) 是由接收、处理特定消息后消费者返回给 RabbitMQ 的，告诉 RabbitMQ 可以删除相应的消息。</p>
<p>如果消费者未返回一个 ack 而被终止（它的信道关闭，连接关闭或者 TCP 连接丢失），RabbitMQ 知道相关的消息没有被完整的处理并重新将其放入队列。如果此时有其它的消费者连接到队列上，RabbitMQ 将快速的将消息重新分发到另一个消费者。这样，就算有工作者意外终止，我们也可以保证没有消息丢失。</p>
<p>目前还没有考虑消息超时。RabbitMQ 会在当消费者意味终止是重新分发消息，甚至处理一个花费很长时间的消息也还算 OK。</p>
<p>本教程中，我们将通过设置 <code>auto-ack</code> 参数的值为 <code>false</code> 来让工作者手动返回消息确认，然后工作者在处理完任务时通过 <code>d.Ack(false)</code>（这个确认只针对于单个分发）将返回一个正确的确认。</p>
<pre><code class="language-go">msgs, err := ch.Consume(
  q.Name, // queue
  &quot;&quot;,     // consumer
  false,  // auto-ack
  false,  // exclusive
  false,  // no-local
  false,  // no-wait
  nil,    // args
)
failOnError(err, &quot;Failed to register a consumer&quot;)

forever := make(chan bool)

go func() {
  for d := range msgs {
    log.Printf(&quot;Received a message: %s&quot;, d.Body)
    dot_count := bytes.Count(d.Body, []byte(&quot;.&quot;))
    t := time.Duration(dot_count)
    time.Sleep(t * time.Second)
    log.Printf(&quot;Done&quot;)
    d.Ack(false)
  }
}()

log.Printf(&quot; [*] Waiting for messages. To exit press CTRL+C&quot;)
&lt;-forever
</code></pre>
<p>使用上面的代码，就算通过 <code>CTRL+C</code> 终止一个正在处理消息的工作者，我们也可以保证没有消息丢失，一旦工作者被终止，所有的尚未确认的消息会被重新分发。</p>
<p>确认必须通过使用分发消息的同一个信道来返回，试图使用不同的信道来返回确认会导致信道级别的协议异常，访问 <a href="https://www.rabbitmq.com/confirms.html">doc guide on confirmations </a> 了解更多。</p>
<blockquote>
<p>Note:</p>
<p><strong>忘记确认</strong></p>
<p>忘记 <code>ack</code> 是很常见的错误，犯错很简单，但后果很严重。当客户端终止时，消息将被（随机地）重新分发，但 RabbitMQ 将因为没有释放未应答的消息吃掉越来越多的内存。</p>
<p>为了能够调试这类错误，可以使用 <code>rabbitmqctl</code> 来打印 <code>messages_unacknowledged</code> 字段：</p>
<pre><code class="language-sh">sudo rabbitmqctl list_queues name messages_ready messages_unacknowledged
</code></pre>
<p>在 Windows 上：</p>
<pre><code class="language-sh">rabbitmqctl.bat list_queues name messages_ready messages_unacknowledge
</code></pre>
</blockquote>
<h2 id="消息持久化">消息持久化</h2>
<p>我们已经掌握了当消费者终止时怎样确保任务不会丢失，但当 RabbitMQ 服务停止时，任务还是会丢失。</p>
<p>当 RabbitMQ 关闭或崩溃时，它将丢失所有的队列和消息，除非你设置它不这样。为了确保消息不会丢失，需要做两件事情：我们需要标记队列和消息时持久化的。</p>
<p>首先，我们需要确保 RabbitMQ 永远不会丢失队列，为此，我们需要设置其为 <code>durable</code>：</p>
<pre><code class="language-golang">q, err := ch.QueueDeclare(
  &quot;hello&quot;,      // name
  true,         // durable
  false,        // delete when unused
  false,        // exclusive
  false,        // no-wait
  nil,          // arguments
)
failOnError(err, &quot;Failed to declare a queue&quot;)
</code></pre>
<p>尽管上面的代码正确无误，但它不会按照我们的期望工作。这是因为我们已经声明了一个不是持久化的名为 <code>hello</code> 的队列了，RabbitMQ 不允许重新声明一个带有不同参数的同名队列，如果尝试这样声明，程序将会返回一个错误。但我们可以通过声明一个不同名字的队列来快速解决这个问题，比如 <code>task_queue</code>：</p>
<pre><code class="language-golang">q, err := ch.QueueDeclare(
  &quot;task_queue&quot;, // name
  true,         // durable
  false,        // delete when unused
  false,        // exclusive
  false,        // no-wait
  nil,          // arguments
)
failOnError(err, &quot;Failed to declare a queue&quot;)
</code></pre>
<p>这里的 <code>durable</code> 选项需要在生成者和消费者代码中同时应用。</p>
<p>这一步中，我们确保了就算 RabbitMQ 重启 <code>task_queue</code> 队列也不会消失。现在，我们需要通过设置 <code>amqp.Publishing</code> 中的 <code>amqp.Persistent</code> 选项将消息标记为持久化的。</p>
<pre><code class="language-go">err = ch.Publish(
  &quot;&quot;,           // exchange
  q.Name,       // routing key
  false,        // mandatory
  false,
  amqp.Publishing {
    DeliveryMode: amqp.Persistent,
    ContentType:  &quot;text/plain&quot;,
    Body:         []byte(body),
})
</code></pre>
<blockquote>
<p>Note:</p>
<p><strong>消息持久化</strong></p>
</blockquote>
<blockquote>
<p>将消息标记为持久化并不能完全保证消失不会丢失。尽管这样设置已经告知 RabbitMQ 将消息保存到磁盘中，但仍有当 RabbitMQ 接收了消息但没有将其保存到磁盘的时间窗口，并且 RabbitMQ 并不会对所有的消息执行 <code>fsync(2)</code> 函数 -- 这样有可能导致消息只保存到了缓存中而没有真正写入磁盘。持久化并未得到强保证，但是对于简单的任务队列已经足够。如果需要持久化更加强的保证，可以使用 <a href="https://www.rabbitmq.com/confirms.html">publisher confirms</a>。</p>
</blockquote>
<h2 id="公平分发">公平分发</h2>
<p>你有可能注意到，有时消息并未按我们期望的那样的分发。设想这样一种情形：有两个工作者，奇数号的消息很重量而偶数号的消息很轻量，一个工作者会一直处于繁忙状态而另一个几乎没有什么工作。RabbitMQ 不会知晓并仍旧平等地分发消息。</p>
<p>导致这种情况是因为 RabbitMQ 当消息进入队列时仅仅分发消息，它不会考虑消费者的未确认消息的个数，它只是盲目地将第 n 号消息发送给第 n 号 消费者。</p>
<figure data-type="image" tabindex="1"><img src="http://img-haotrr.test.upcdn.net/blog/2-1-prefetch-count.png" alt="2-1-prefetch-count" loading="lazy"></figure>
<p>为了解决上述问题，我们可以将预取数设置为 1，这样我们告诉 RabbitMQ 不要同时分发给一个工作者超过 1 的消息。或者说，在工作者没有处理完任何并返回确认时不要给它分发新的消息，这样 RabbitMQ 将信息分发给了两外那个不忙的工作者。</p>
<pre><code class="language-go">err = ch.Qos(
  1,     // prefetch count
  0,     // prefetch size
  false, // global
)
failOnError(err, &quot;Failed to set QoS&quot;)
</code></pre>
<blockquote>
<p>Note:</p>
<p><strong>队列容量</strong></p>
<p>当所有的工作者都处于繁忙状态，队列有可能会被填满，这一点需要引起注意，可以通过增加更多的工作者或其它方法解决。</p>
</blockquote>
<h2 id="整体来看">整体来看</h2>
<p>最终的 <code>new_task.go</code> 代码：</p>
<pre><code class="language-go">package main

import (
        &quot;fmt&quot;
        &quot;log&quot;
        &quot;os&quot;
        &quot;strings&quot;

        &quot;github.com/streadway/amqp&quot;
)

func failOnError(err error, msg string) {
        if err != nil {
                log.Fatalf(&quot;%s: %s&quot;, msg, err)
                panic(fmt.Sprintf(&quot;%s: %s&quot;, msg, err))
        }
}

func main() {
        conn, err := amqp.Dial(&quot;amqp://guest:guest@localhost:5672/&quot;)
        failOnError(err, &quot;Failed to connect to RabbitMQ&quot;)
        defer conn.Close()

        ch, err := conn.Channel()
        failOnError(err, &quot;Failed to open a channel&quot;)
        defer ch.Close()

        q, err := ch.QueueDeclare(
                &quot;task_queue&quot;, // name
                true,         // durable
                false,        // delete when unused
                false,        // exclusive
                false,        // no-wait
                nil,          // arguments
        )
        failOnError(err, &quot;Failed to declare a queue&quot;)

        body := bodyFrom(os.Args)
        err = ch.Publish(
                &quot;&quot;,           // exchange
                q.Name,       // routing key
                false,        // mandatory
                false,
                amqp.Publishing{
                        DeliveryMode: amqp.Persistent,
                        ContentType:  &quot;text/plain&quot;,
                        Body:         []byte(body),
                })
        failOnError(err, &quot;Failed to publish a message&quot;)
        log.Printf(&quot; [x] Sent %s&quot;, body)
}

func bodyFrom(args []string) string {
        var s string
        if (len(args) &lt; 2) || os.Args[1] == &quot;&quot; {
                s = &quot;hello&quot;
        } else {
                s = strings.Join(args[1:], &quot; &quot;)
        }
        return s
}
</code></pre>
<p><a href="http://github.com/rabbitmq/rabbitmq-tutorials/blob/master/go/new_task.go">new_task.go</a></p>
<p><code>worker.go</code> 代码：</p>
<pre><code class="language-go">package main

import (
        &quot;bytes&quot;
        &quot;fmt&quot;
        &quot;github.com/streadway/amqp&quot;
        &quot;log&quot;
        &quot;time&quot;
)

func failOnError(err error, msg string) {
        if err != nil {
                log.Fatalf(&quot;%s: %s&quot;, msg, err)
                panic(fmt.Sprintf(&quot;%s: %s&quot;, msg, err))
        }
}

func main() {
        conn, err := amqp.Dial(&quot;amqp://guest:guest@localhost:5672/&quot;)
        failOnError(err, &quot;Failed to connect to RabbitMQ&quot;)
        defer conn.Close()

        ch, err := conn.Channel()
        failOnError(err, &quot;Failed to open a channel&quot;)
        defer ch.Close()

        q, err := ch.QueueDeclare(
                &quot;task_queue&quot;, // name
                true,         // durable
                false,        // delete when unused
                false,        // exclusive
                false,        // no-wait
                nil,          // arguments
        )
        failOnError(err, &quot;Failed to declare a queue&quot;)

        err = ch.Qos(
                1,     // prefetch count
                0,     // prefetch size
                false, // global
        )
        failOnError(err, &quot;Failed to set QoS&quot;)

        msgs, err := ch.Consume(
                q.Name, // queue
                &quot;&quot;,     // consumer
                false,  // auto-ack
                false,  // exclusive
                false,  // no-local
                false,  // no-wait
                nil,    // args
        )
        failOnError(err, &quot;Failed to register a consumer&quot;)

        forever := make(chan bool)

        go func() {
                for d := range msgs {
                        log.Printf(&quot;Received a message: %s&quot;, d.Body)
                        dot_count := bytes.Count(d.Body, []byte(&quot;.&quot;))
                        t := time.Duration(dot_count)
                        time.Sleep(t * time.Second)
                        log.Printf(&quot;Done&quot;)
                        d.Ack(false)
                }
        }()

        log.Printf(&quot; [*] Waiting for messages. To exit press CTRL+C&quot;)
        &lt;-forever
}
</code></pre>
<p><a href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/go/worker.go">worker.go</a></p>
<p>通过消息确认和设置预取数，我们可以创建一个工作队列，而持久化选项可以在 RabbitMQ 重启的情况下保存我们的任务。</p>
<p>更多关于 <code>amqp.Channel</code> 方法和消息的属性，请参考 <a href="http://godoc.org/github.com/streadway/amqp">amqp API reference</a>。</p>
<p>接下来，请移步至 <a href="/post/rabbitmq-tutorial-go-3/">教程三</a> 来掌握怎样将同一消息发送给很多消费者。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[RabbitMQ 入门教程（一）- "Hello World!"]]></title>
        <id>https://haotrr.github.io/post/rabbitmq-tutorial-go-1/</id>
        <link href="https://haotrr.github.io/post/rabbitmq-tutorial-go-1/">
        </link>
        <updated>2018-09-29T06:47:00.000Z</updated>
        <summary type="html"><![CDATA[<p>本系列是 RabbitMQ 官方教程 Go 版本的中译版本，本文为第一篇，简单介绍 RabbitMQ 最基本的生产-消费者模式。</p>
]]></summary>
        <content type="html"><![CDATA[<p>本系列是 RabbitMQ 官方教程 Go 版本的中译版本，本文为第一篇，简单介绍 RabbitMQ 最基本的生产-消费者模式。</p>
<!-- more -->
<p><a href="http://www.rabbitmq.com/tutorial-one-go.html">教程一 原文地址: &quot;Hello World!&quot;</a></p>
<h2 id="介绍">介绍</h2>
<p>RabbitMQ 是一个消息代理：接收然后投递消息。你可以把它看做一个邮局：你把你想要寄送的邮件投递到邮箱里，显然邮递员最终会将你的邮件投递到收件人手上。类似地，RabbitMQ 就像是一个邮箱，一个邮局或者一个邮递员。</p>
<p>RabbitMQ 与邮局的最大的区别在于，RabbitMQ 不处理信件而是接收、储存和传递二进制数据 -- 消息。</p>
<p>RabbitMQ，或者更一般的消息，使用了一些专业术语。</p>
<blockquote>
<p><code>生产</code>代指发送，一个发送消息的应用程序则被称为<code>生产者</code>。</p>
</blockquote>
<figure data-type="image" tabindex="1"><img src="http://img-haotrr.test.upcdn.net/blog/1-1-producer.png" alt="1-1-producer.png" loading="lazy"></figure>
<blockquote>
<p>一个<code>队列</code>像是 RabbitMQ 里面的一个邮箱。尽管消息通过 RabbitMQ 在你的应用间相互传递，但消息只能保存在<code>队列</code>中。一个<code>队列</code>大小只受限于主机的内存和磁盘大小，它本质上是一个大的消息缓存。不同的<code>生产者</code>可以将消息发送到同一个队列，不同的<code>消费者</code>也可以从同一队列获取数据。以下图示代表了一个队列。</p>
</blockquote>
<figure data-type="image" tabindex="2"><img src="http://img-haotrr.test.upcdn.net/blog/1-2-queue.png" alt="1-2-queue.png" loading="lazy"></figure>
<blockquote>
<p><code>消费</code>代指接收，<code>消费者</code>指的是一个等待接收消息的应用程序。</p>
</blockquote>
<figure data-type="image" tabindex="3"><img src="http://img-haotrr.test.upcdn.net/blog/1-3-consumer.png" alt="1-3-consumer.png" loading="lazy"></figure>
<p>注意生产者、消费者和消息代理不一定需要存在于同一台主机上，且对大部分应用程序来说，这才是常态。一个应用程序有可能既是生成者，也是消费者。</p>
<h2 id="hello-world">“Hello World”</h2>
<p>本教程中，我们使用 Go 编写两个小程序：一个生产者程序用于发送一条简单的消息，一个消费者程序接收信息并将其打印。作为开始，我们将跳过 <a href="https://godoc.org/github.com/streadway/amqp">Go RabbitMQ</a> API 的阐述, 将主要集中精力在简单的事情上：发送一条 “Hello World” 的消息。</p>
<p>在下面的图示中，“P” 代表生产者，“C” 代表消费者，中间的盒子代表一个队列 -- RabbitMQ 中为消费者保存消息的消息缓存。</p>
<figure data-type="image" tabindex="4"><img src="http://img-haotrr.test.upcdn.net/blog/1-4-p-q-c-model.png" alt="1-4-p-q-c-model.png" loading="lazy"></figure>
<blockquote>
<p>Note:</p>
<p><strong>Go RabbitMQ 客户端库</strong></p>
<p>RabbitMQ 提供多种协议。本教程中使用开源、general-purpose 消息通信协议 AMQP 0-9-1。RabbitMQ 在页面 <a href="http://rabbitmq.com/devtools.html">RabbitMQ - Clients &amp; Developer Tools</a> 提供了一系列语言的客户端库。本教程中，我们使用 Go AMQP 客户端库。</p>
<p>使用 <code>go get</code> 安装 AMQP Go 客户端库：</p>
<pre><code class="language-go">go get github.com/streadway/amqp
</code></pre>
</blockquote>
<p>安装好 AMQP 客户端库后，我们便可以写代码了。</p>
<h2 id="发送">发送</h2>
<figure data-type="image" tabindex="5"><img src="http://img-haotrr.test.upcdn.net/blog/1-5-sending.png" alt="1-5-sending.png" loading="lazy"></figure>
<p>我们将消息的发布者（发送者）命名为 <code>seng.go</code>，将消息的消费者（接收者）命名为 <code>receive.go</code>。发布者会连接到 RabbitMQ，发送一条消息，然后退出。</p>
<p>在 <code>send.go</code> 中，我们首先导入相关包：</p>
<pre><code class="language-go">package main

import (
  &quot;fmt&quot;
  &quot;log&quot;

  &quot;github.com/streadway/amqp&quot;
)
</code></pre>
<p>接着，我们声明一个用于检查每一次 AMQP 库函数调用返回值的辅助函数：</p>
<pre><code class="language-go">func failOnError(err error, msg string) {
  if err != nil {
    log.Fatalf(&quot;%s: %s&quot;, msg, err)
    panic(fmt.Sprintf(&quot;%s: %s&quot;, msg, err))
  }
}
</code></pre>
<p>然后，连接 RabbitMQ 服务器：</p>
<pre><code class="language-go">conn, err := amqp.Dial(&quot;amqp://guest:guest@localhost:5672/&quot;)
failOnError(err, &quot;Failed to connect to RabbitMQ&quot;)
defer conn.Close()
</code></pre>
<p>上面代码中的连接封装了 Socket 连接，将诸如协议本版、协议握手、身份认证等细节隐藏了。接下来，我们创建一个信道，我们所有的 API 调用都将基于信道：</p>
<pre><code class="language-go">ch, err := conn.Channel()
failOnError(err, &quot;Failed to open a channel&quot;)
defer ch.Close()
</code></pre>
<p>为了发送消息，我们还必须声明一个消息将要发往的队列，这样我们才能将消息发送到队列中：</p>
<pre><code class="language-go">q, err := ch.QueueDeclare(
  &quot;hello&quot;, // name
  false,   // durable
  false,   // delete when unused
  false,   // exclusive
  false,   // no-wait
  nil,     // arguments
)
failOnError(err, &quot;Failed to declare a queue&quot;)

body := &quot;hello&quot;
err = ch.Publish(
  &quot;&quot;,     // exchange
  q.Name, // routing key
  false,  // mandatory
  false,  // immediate
  amqp.Publishing {
    ContentType: &quot;text/plain&quot;,
    Body:        []byte(body),
  })
failOnError(err, &quot;Failed to publish a message&quot;)
</code></pre>
<p>声明一个队列时幂等的 -- 只有当队列不存在的时候，才会去创建这个队列。消息内容是一个字节数组（byte array），这样我们就能将任何想要的数据编码在里面了。</p>
<p>这里是完整的 <a href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/go/send.go">send.go</a> 文件。</p>
<blockquote>
<p>Note:</p>
<p><strong>发送并没有成功！</strong></p>
<p>如果这是你第一次使用 RabbitMQ 并且没有看到“发送”出去的消息，你可能会想是不是哪里出现了错误。可能的原因是消息代理启动的时候没有分配到做够的磁盘空间（默认情况下至少需要 200 MB ）从而无法接收消息。检查消息代理的日志确认或者必要时增大限制值。页面 <a href="https://www.rabbitmq.com/configure.html#config-items">RabbitMQ - RabbitMQ Configuration</a> 展示了如何修改 <code>disk_free_limit</code> 的值。</p>
</blockquote>
<h2 id="接收">接收</h2>
<p>以上就是一个完整的发布者。而消费者将从 RabbitMQ 拉取消息，所以不像发布者那样发送一条消息，消费者将一直监听消息并将其打印出来。</p>
<figure data-type="image" tabindex="6"><img src="http://img-haotrr.test.upcdn.net/blog/1-6-receiving.png" alt="1-6-receiving.png" loading="lazy"></figure>
<p><a href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/go/receive.go">receive.go</a> 代码中与 send 中有相同的导入和帮助函数：</p>
<pre><code class="language-go">package main

import (
  &quot;fmt&quot;
  &quot;log&quot;

  &quot;github.com/streadway/amqp&quot;
)

func failOnError(err error, msg string) {
  if err != nil {
    log.Fatalf(&quot;%s: %s&quot;, msg, err)
    panic(fmt.Sprintf(&quot;%s: %s&quot;, msg, err))
  }
}
</code></pre>
<p>与生产者的设置一样，我们依同样建立连接和打开信道，然后在声明一个要消费的队列。注意我们需要声明一个与 send 中发布消息匹配的队列：</p>
<pre><code class="language-go">conn, err := amqp.Dial(&quot;amqp://guest:guest@localhost:5672/&quot;)
failOnError(err, &quot;Failed to connect to RabbitMQ&quot;)
defer conn.Close()

ch, err := conn.Channel()
failOnError(err, &quot;Failed to open a channel&quot;)
defer ch.Close()

q, err := ch.QueueDeclare(
  &quot;hello&quot;, // name
  false,   // durable
  false,   // delete when usused
  false,   // exclusive
  false,   // no-wait
  nil,     // arguments
)
failOnError(err, &quot;Failed to declare a queue&quot;)
</code></pre>
<p>注意，我们再一次声明了一个队列。因为消费者有可能比生产者先运行，为了想要确保该队列在我们消费消息前就已经存在，我们必须这样做。</p>
<p>接下来，我们告诉服务器从队列中传递给我们需要消费的消息。鉴于消息将会以异步的方式发送过来，我们在（Go 语言中）一个 goroutine 中的使用管道来接收消息：</p>
<pre><code class="language-go">msgs, err := ch.Consume(
  q.Name, // queue
  &quot;&quot;,     // consumer
  true,   // auto-ack
  false,  // exclusive
  false,  // no-local
  false,  // no-wait
  nil,    // args
)
failOnError(err, &quot;Failed to register a consumer&quot;)

forever := make(chan bool)

go func() {
  for d := range msgs {
    log.Printf(&quot;Received a message: %s&quot;, d.Body)
  }
}()

log.Printf(&quot; [*] Waiting for messages. To exit press CTRL+C&quot;)
&lt;-forever
</code></pre>
<p>这里是完整的 <a href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/go/receive.go">receive.go</a> 文件。</p>
<h2 id="作为一个整体">作为一个整体</h2>
<p>现在我们同时运行两个程序。在一个终端中，运行发布者：</p>
<pre><code class="language-sh">go run send.go
</code></pre>
<p>在另一个终端运行消费者：</p>
<pre><code class="language-sh">go run receive.go
</code></pre>
<p>消费者将打印发布者通过 RabbitMQ 发送过来的消息。消费者会一直运行等待消息（使用 Ctrl-C 来停止），所以可以尝试从不同的终端来运行发布者。</p>
<p>如果想要查看队列信息，运行命令 <code>rabbitmqctl list_queues</code>。</p>
<p>接下来，请移步至 <a href="/post/rabbitmq-tutorial-go-2/">教程二</a> 创建一个简单的 <em>工作队列</em>。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SOLID Go 设计（译）]]></title>
        <id>https://haotrr.github.io/post/solid-go-design/</id>
        <link href="https://haotrr.github.io/post/solid-go-design/">
        </link>
        <updated>2018-07-09T14:25:37.000Z</updated>
        <summary type="html"><![CDATA[<p>接口让我们 Go 开发者描述了我们提供包是做什么的，而不是如何实现的。换个说法就是「解耦」，这确实是我们的目标，因为解耦的软件修改起来更容易。</p>
]]></summary>
        <content type="html"><![CDATA[<p>接口让我们 Go 开发者描述了我们提供包是做什么的，而不是如何实现的。换个说法就是「解耦」，这确实是我们的目标，因为解耦的软件修改起来更容易。</p>
<!-- more -->
<hr>
<p>原文链接：<a href="https://dave.cheney.net/2016/08/20/solid-go-design">OLID Go Design - Dave Cheney</a></p>
<p><em>本文的写作基于我 2016 年 8 月 18 日在 GolangUK 上进行演讲的 Keynote 文档。</em></p>
<p><em>本次演讲的影像可在 <a href="https://www.youtube.com/watch?v=zzAdEt3xZ1M">YouTube </a>上进行查看。</em></p>
<h2 id="世界上有多少-go-开发者">世界上有多少 Go 开发者？</h2>
<p>世界上有多少 Go 开发者？好好想一想这个数字并记在脑海里面，在演讲的最后我们再来看看这个数字。</p>
<h2 id="代码评审">代码评审</h2>
<p>在座的各位有哪些人把代码评审作为日常工作的一部分？【整个房间的人都举起了手，真是令人鼓舞呐！】好了，哪为什么要进行代码评审？【有人大喊「移除坏的代码」】</p>
<p>如果进行代码评审是捕捉坏的代码，那么你怎么知道你所审查的代码是好是坏？</p>
<p>你可以说「那些代码丑陋极了」或者「哇，这些代码真优雅」，就如你可以说「这幅画真好看」或者「这间房间真漂亮」。但是这些描述都是形容词，接下来，让我来找一些客观的方式来谈一谈代码是好是坏。</p>
<h2 id="糟糕的代">糟糕的代</h2>
<p>在进行代码审查的时候，你会选择下面哪些作为坏代码的特征？</p>
<ul>
<li><em>死板（Rigid）</em> - 代码是否死板？它是否有过于强类型或参数导致对其修改起来很困难？</li>
<li><em>脆弱（Fragile）</em> - 代码是否脆弱？对代码做轻微的改变是否就会引起程序数不清的破坏？</li>
<li><em>难以改变（Immobile）</em> - 代码是否很难重构？是否一个按键就会导致循环引用？</li>
<li><em>复杂（Complex）</em> - 代码是否因为其它代码的缘故导致过度的设计？</li>
<li><em>冗长（Verbose）</em> - 代码是否用起来很费劲？当查阅代码时，是否很难看出来代码在做什么？</li>
</ul>
<p>以上的都是听起来很不错的词汇吗？当你进行代码审查的时候看到这些词语会愉快吗？</p>
<p>当然不会。</p>
<h2 id="好的设计">好的设计</h2>
<p>如果有一些描述优秀的设计属性的方式就更好了，不仅仅是糟糕的设计，是否能在客观条件下做？</p>
<h2 id="solid-面向对象设计">SOLID - 面向对象设计</h2>
<p>在 2002 年，Robert Martin 写的 <a href="https://www.amazon.co.uk/dp/0135974445/ref=pd_lpo_sbs_dp_ss_2/253-1946330-6751666?pf_rd_m=A3P5ROKL5A1OLE&amp;pf_rd_s=lpo-top-stripe&amp;pf_rd_r=23C4AHYV7EXGYHKD6G8Q&amp;pf_rd_t=201&amp;pf_rd_p=569136327&amp;pf_rd_i=0132760584">Agile Software Development, Principles, Patterns, and Practices</a> 一书中，他介绍了五个可重用软件设计的原则 - “SOLID”（由英文首字母缩略而来）。</p>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/%E5%8D%95%E4%B8%80%E5%8A%9F%E8%83%BD%E5%8E%9F%E5%88%99">单一功能原则（Single Responsibility Principle）</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99">开闭原则（Open / Closed Principle）</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99">里氏替换原则（Liskov Substitution Principle）</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99">接口隔离原则（Interface Segregation Principle）</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E4%BE%9D%E8%B5%96%E5%8F%8D%E8%BD%AC%E5%8E%9F%E5%88%99">依赖反转原则（Dependency Inversion Principle）</a></li>
</ul>
<p>这本书有点儿过时，书中谈论的语言也是十多年前的。但是，或许 SOLID 原则中的某些方面可以给我们一些关于如何精心设计的 Go 程序的线索。</p>
<h3 id="单一功能原则">单一功能原则</h3>
<p>SOLID 的第一条原则，S，就是单一功能原则（Single Responsibility Principle）。</p>
<blockquote>
<p>A class should have one, and only one, reason to change. – Robert C Martin</p>
</blockquote>
<p>Go 中显然没有类（Classes）这个概念，然而，我们有更为强大的组合（Composition）概念。当然，如果你可以回顾一下类这个术语的使用，我认为这里面自有其价值。</p>
<p>为什么一段代码的改变应该只有一个原因是如此的重要？跟你自己的修改代码引起的烦恼比起来，发现自己代码所依赖的代码的修改会更令人头疼。而且，当你的代码不得不要修改的时候，它应该负责直接作为促进因素，而不应该是附带的受害者。</p>
<p>所以，有单一功能原则代码因此要有最少的原因来改变。</p>
<h4 id="耦合与内聚">耦合与内聚</h4>
<p>耦合和内聚（ Coupling &amp; Cohesion）这两个词语用于描绘修改一段软件代码的难易程度。</p>
<p><em>耦合（Coupling）</em> 简单的用于描述两个东西将同时改变：其中一个变化会引发另外一个变化。<br>
<em>内聚（Cohesion）</em> 是相互关联但又隔离，一种相互吸引的力量。</p>
<p>在软件领域，内聚用来描述一段代码自然地与另外一段代码有联系的属性。</p>
<p>要描述 Go 程序中的耦合与内聚，我们可以要看一下函数（functions）和方法（methods），当讨论单一功能原则时它们很常见，但是首先还是来看看 Go 的包（package）模型。</p>
<h4 id="go-包">Go 包</h4>
<p>在 Go 中，所有的代码都在某个包中，设计得好的包始于命名。包名不仅提供了其目的的描述，还提供了一个命名空间的前缀。Go 标准库里有一些好的例子：</p>
<ul>
<li><code>net/http</code> ：提供了 HTTP 客户端和服务端</li>
<li><code>os/exec</code> ：执行外部的命令</li>
<li><code>encoding/json</code> ：实现了 JSON 的编码与解码</li>
</ul>
<p>当你通过使用 <code>import</code> 声明来在自己的项目中使用其它包的时候，它会在两个包之间建立一个源码级别的耦合，两个包彼此关联。</p>
<h4 id="坏的包名">坏的包名</h4>
<p>关注命名并不是出于卖弄。糟糕的命名将失去罗列其目的的机会。</p>
<p><code>server</code> 包提供了什么？好吧，正如是期望的服务功能，但是什么协议的实现？</p>
<p><code>private</code> 包提供了什么？一些我不该看到的功能？它是否应该提供一些导出的标识符？</p>
<p>还有 <code>common</code> ，就像它的同伙 <code>utils</code>一样，经常会被一些包维护者使用。诸如此类的包名已经成为了杂项的垃圾场，因为其责任的多样性导致这些包被毫无来由的频繁修改。</p>
<h4 id="go-的-unix-哲学">Go 的 Unix 哲学</h4>
<p>在我看来，涉及到解耦设计必须要提及 Doug McIlroy 的 Unix 哲学：小巧而有力的工具的结合起来可以解决更大和更常见的任务，这些任务通常是其连原作者并没有预想到的任务。</p>
<p>我认为 Go 的包正体现了 Unix 哲学精神，实际上每个包自身就是一个具有单一原则变化单元的小型 Go 项目。</p>
<h3 id="开闭原则">开闭原则</h3>
<p>第二条 SOLID 原则，O，是由 Bertrand Meyer 与 1988 提出的开闭原则（Open / Closed Principle），他写道：</p>
<blockquote>
<p>Software entities should be open for extension, but closed for modification. – Bertrand Meyer, Object-Oriented Software Construction</p>
</blockquote>
<p>该建议如何应用到 20 多年后的编程语言中呢？</p>
<pre><code class="language-go">package main
type A struct {
	year int
}
func (a A) Greet() {
	fmt.Println(&quot;Hello GolangUK&quot;, a.year)
}
type B struct {
	A
}
func (b B) Greet() {
	fmt.Println(&quot;Welcome to GolangUK&quot;, b.year)
}
func main() {
	var a A
	a.year = 2016
	var b B
	b.year = 2016
	a.Greet() // Hello GolangUK 2016
 	b.Greet() // Welcome to GolangUK 2016
}
</code></pre>
<p>我们定义了类型<code>A</code> ，它包含一个 <code>year</code> 字段和一个 <code>Greet</code> 方法。 我们定义了第二个类型 <code>B</code> ，它嵌入了 <code>A</code> 。因为 <code>A</code> 是作为一个字段嵌入到 <code>B</code> 中的，所以调用者能看到 <code>B</code> 的方法，它提供的 <code>Greet</code> 的方法会覆盖 <code>A</code> 的（同名）方法。</p>
<p>但是嵌入不仅局限于方法，它还能提供嵌入类型的字段访问。如你所见，由于 <code>A</code> 和 <code>B</code> 在同一个包内声明， <code>B</code> 可以访问 <code>A</code> 的私有字段 <code>year</code> ，就如同 <code>B</code> 已经声明过这个字段一样。</p>
<p>因此嵌入是一个允许 Go 类型对扩展开放的强大工具。</p>
<pre><code class="language-go">package main
type Cat struct {
	Name string
}
func (c Cat) Legs() int { return 4 }
func (c Cat) PrintLegs() {
	fmt.Printf(&quot;I have %d legs\n&quot;, c.Legs())
}
type OctoCat struct {
	Cat
}
func (o OctoCat) Legs() int { return 5 }
func main() {
	var octo OctoCat
	fmt.Println(octo.Legs()) 	// 5
 	octo.PrintLegs()    // I have 4 legs
}
</code></pre>
<p>在上边这个例子中，类型  <code>Cat</code> 有 <code>Legs</code> 方法来计算它有几条腿。我们将 <code>Cat</code> 嵌入到一个新的类型 <code>OctoCat</code> 中，并声明 <code>Octocats</code> 有五条腿。然而，尽管 <code>OctoCat</code> 类型定义了一个返回 5 的 <code>Legs</code>  方法，但在 <code>PrintLegs</code> 方法被调用时会返回 4。</p>
<p>这是因为 <code>PrintLegs</code> 方法是在 <code>Cat</code> 类型中定义的。它将使用 <code>Cat</code> 做为它的接收者，因此它会使用 <code>Cat</code> 的 <code>Legs</code> 方法。 <code>Cat</code> 并不了解已嵌入的类型，因此它的嵌入方法不能被修改。</p>
<p>由此，我们可以说 Go 的类型<em>对扩展是开放的</em>，但是<em>对修改是关闭的</em>。</p>
<p>事实上，Go 接收者的方法仅仅是带有预先声明形参的函数的语法糖而已。</p>
<pre><code class="language-go">func (c Cat) PrintLegs() {
        fmt.Printf(&quot;I have %d legs\n&quot;, c.Legs())
}
func PrintLegs(c Cat) {
        fmt.Printf(&quot;I have %d legs\n&quot;, c.Legs())
}
</code></pre>
<p>你传递给函数的第一个参数就是函数的接收者，因为 Go 不支持重载，所以 <code>OctoCat</code> 并不能替换普通的 <code>Cat</code> ，这就引出了接下来一个原则。</p>
<h3 id="里氏替换原则">里氏替换原则</h3>
<p>里氏替换原则（Liskov Substitution Principle）由 Barbara Liskov 提出，大意是，如果调用者不能区分两种类型行为上的不同，那么他们是可替代的。</p>
<p>基于类（Class）的编程语言，里氏替换原则通常被解释为一个抽象基类的各种具体子类的规范。但是 Go 没有类或者继承（Inheritance），因此就不能以抽象类的层次结构实现替换。</p>
<h4 id="接口interfaces">接口（Interfaces）</h4>
<p>然而，Go 的接口（Interface）有能力替换。在 Go 中，类型不需要声明他们具体要实现的某个接口，相反的，任何想要实现接口的类型仅需提供与接口声明相匹配的方法即可。</p>
<p>就 Go 而言，接口是隐式实现的，而非显式的，这也深刻地影响着接口在语言中的使用方式。</p>
<p>精心设计的接口更可能是小巧的，流行的做法是一个接口只包含一个方法。逻辑上来讲小巧的接口使实现变得简单，反之就很难做到。这就产生了由常见行为连接的简单实现而组成的包。</p>
<h4 id="ioreader">io.Reader</h4>
<pre><code class="language-go">type Reader interface {
        // Read reads up to len(buf) bytes into buf.
        Read(buf []byte) (n int, err error)
}
</code></pre>
<p>下面来看看我最喜爱的 Go 接口： <code>io.Reader</code>。</p>
<p><code>io.Reader</code> 接口非常简单， <code>Read</code> 读取数据到提供的缓冲区（buffer）中，并返回调用者读取数据的字节（bytes）的数量以及读取期间可能的错误。它简单但强大。</p>
<p>因为 <code>io.Reader</code> 可以处理任何能表示为字节流（bytes）的数据，我们可以在任何事情上构建 Readers：字符串（string）常量、字节（byte）数组、标准输入、网络数据流、gzip 后的 tar 文件以及通过 SSH 远程执行的命令的标准输出等等。</p>
<p>因为它们都满足了相同的协议契约，所有这些实现相互之间都是可替换的。</p>
<p>因此，里氏替换原则应用在 Go 中，可以用 Jim Weirich 的格言来概括：</p>
<blockquote>
<p>Require no more, promise no less. – Jim Weirich</p>
</blockquote>
<p>接下来让我们切换到 SOLID 第四个原则。</p>
<h3 id="接口隔离原则">接口隔离原则</h3>
<p>第四个原则是接口隔离原则（Interface Segregation Principle），描述如下：</p>
<blockquote>
<p>Clients should not be forced to depend on methods they do not use. – Robert C. Martin</p>
</blockquote>
<p>在 Go 中，接口隔离原则的应用可以表示成：为了完成一个孤立的行为，我们需要一个单独的方法。举个具体的例子，编写一个方法来保存一个文档结构到磁盘这样的任务。</p>
<pre><code class="language-go">// Save writes the contents of doc to the file f.
func Save(f *os.File, doc *Document) error
</code></pre>
<p>我可以定义一个名为 <code>Save</code> 方法，它使用 <code>*os.File</code> 做为保存 <code>Document</code> 的文件。但是这样做存在一些问题。</p>
<p><code>Save</code> 方法的签名中排除了保存数据到网络位置的选项。假如过后要加入网络储存的需求，那么该方法的签名就需要修改，这会影响到所有使用该方法的调用者。</p>
<p>因为 <code>Save</code> 直接地操作磁盘上的文件，测试起来很不方便。要验证这个操作，测试不得不在文件被写入后读取其内容，另外测试必须确保 <code>f</code> 被写入一个临时的位置而且过后要记得删除。</p>
<p><code>*os.File</code> 还包含了许多跟 <code>Save</code> 无关的方法，比如读取路径以及检查路径是否为软连接。如果 <code>Save</code> 方法的签名只描述 <code>*os.File</code> 相关的部分将会非常有用。</p>
<p>我们如何解决这些？</p>
<pre><code class="language-go">// Save writes the contents of doc to the supplied ReadWriterCloser.
func Save(rwc io.ReadWriteCloser, doc *Document) error
</code></pre>
<p>使用 <code>io.ReadWriteCloser</code> 来应用接口隔离原则，从而重新定义 <code>Save</code> 方法，让它接收一个接口类型来描述更为通用的像形如文件这样的类型（file-shaped）。</p>
<p>随着修改，任何实现了 <code>io.ReadWriteCloser</code> 接口类型都可以代替之前的 <code>*os.File</code> 。这使得 <code>Save</code> 不仅扩展了应用范围，同时也对 <code>Save</code> 的调用者说明了 <code>*os.File</code> 的哪些方法是与当前操作相关的。</p>
<p>做为 <code>Save</code> 的作者，我不再有在 <code>*os.File</code> 上调用无关的方法机会了，因为它们都被隐藏于 <code>io.ReadWriteCloser</code> 接口之中了。我们还可以进一步地应用接口隔离原则。</p>
<p>首先，（上述） <code>Save</code> 方法不太可能会保持单一功能原则，因为它要读取的用于验证的文件内容应该是另外一段代码的责任。因此我们可以缩小接口范围，只传入 <code>writing</code> 和 <code>closing</code> 。</p>
<pre><code class="language-go">// Save writes the contents of doc to the supplied WriteCloser.
func Save(wc io.WriteCloser, doc *Document) error
</code></pre>
<p>其次，通过向 <code>Save</code> 提供一种机制来关闭它的数据流，它来自于我们之前一直想要把这个参数看起来像文件这样的类型（file-shaped），这会导致另外一个问题： <code>wc</code> 会在什么情况下关闭？ <code>Save</code> 可能会无条件的调用 <code>Close</code> ， 又或在成功的情况下调用了 <code>Close</code> 。</p>
<p>当 <code>Save</code> 的调用者在写入文件之后再写入额外的数据时就会引发问题。</p>
<pre><code class="language-go">type NopCloser struct {
        io.Writer
}
// Close has no effect on the underlying writer.
func (c *NopCloser) Close() error { return nil }
</code></pre>
<p>一个原始解决方案回事定义一个新的类型，向它内嵌入 <code>io.Writer</code> 并重写 <code>Close</code> 方法来阻止 <code>Save</code> 方法关闭底层数据流。</p>
<p>但是如果 <code>NopCloser</code> 实际上并未关闭任何东西，可能会导致它违反里氏替换原则，。</p>
<pre><code class="language-go">// Save writes the contents of doc to the supplied Writer.
func Save(w io.Writer, doc *Document) error
</code></pre>
<p>一个更好的解决办法是重新定义 <code>Save</code> ，让它只传入 <code>io.Writer</code> ，剥离它除了写入数据到数据流之外的所有责任。</p>
<p>通过对 <code>Save</code> 函数应用接口隔离原则，结果我们得到了一个满足需求的，同时又最具体（只需要写就可以了）又最通用的函数，我们现在可以使用 <code>Save</code> 函数来保存数据到任何实现了 <code>io.Writer</code> 的地方。</p>
<blockquote>
<p>A great rule of thumb for Go is  <strong>accept interfaces, return structs</strong>. – Jack Lindamood</p>
</blockquote>
<p>稍作回顾，这句话是一个非常有意思的文化现象（meme），这几年以来，它已经渗透到了 Go 的潮流文化之中了。</p>
<p>这条推文有好几个细微差别的版本，这不怪 Jack，但我认为它代表了一些可拥护的 Go 设计原则。</p>
<h3 id="依赖反转原则">依赖反转原则</h3>
<p>最后一条 SOLID 原则，依赖反转原则（Dependency Inversion Principle），定义如下：</p>
<blockquote>
<p>High-level modules should not depend on low-level modules.<br>
Both should depend on abstractions.<br>
Abstractions should not depend on details. Details should depend on abstractions.<br>
– Robert C. Martin</p>
</blockquote>
<p>对 Go 程序员而言，依赖反转意味着什么呢：</p>
<p>如果你应用前面提到的所有的原则，你的代码应该已经被分解成离散的且带有明确责任和目的的包了。你的代码应该描述了它依赖的接口，并且这些接口只描述他们需要的功能行为。换句话说，它们不会再过多的改变。</p>
<p>因此，我认为 Martin 在这里所讲的在，就是 Go 应用的上下文（context），即你的导入图（import graph）。</p>
<p>在 Go 中，你的导入图必须是非循环。不遵守非循环会导致编译错误，但是更为严重的是，这代表了一系列的设计错误。</p>
<p>相同情况下，精心设计的导入图应该是宽且相对扁平的，而不是又高又窄。如果你有一个包，它的函数在没有其他包的支持的情况下便无法操作，这也许表明了你的代码中没有好好思考包的边界。</p>
<p>依赖反转原则鼓励你尽可能将具体细节负责往导入图上层的地方放，如 <code>main</code> 包或者高层级的处理程序（handler）等，让低层级代码来处理抽象的接口。</p>
<h2 id="solid-go-程序设计">SOLID Go 程序设计</h2>
<p>回顾一下，当应用 Go 程序设计中，每个 SOLID 原则都是强有力的声明，但当是加在一起他们则有一个中心主题。</p>
<p>单一功能原则鼓励你在包中组织函数、类型以及方法时，表现出自然的内聚力。类型属于彼此，函数或方法为单一的目的而服务。</p>
<p>开闭原则鼓励你使用嵌入将简单的类型组合成更为复杂的类型。</p>
<p>里氏替换原则鼓励你在包之间表达依赖关系时用接口，而非具体类型。通过定义小巧的接口，我们可以更加确信具体的实现能很好地满足接口协议。</p>
<p>接口隔离原则让上一条规则走得更远，它鼓励你仅取决于所需行为来定义函数和方法。因为如果你的函数仅仅需要只有一个方法的接口类型做为参数，那么它很有可能只有一个责任。</p>
<p>依赖反转原则鼓励你在编译时将包所依赖的东西移除，在 Go 中我们可以看到这样做使得运行时用到的某个特定的包的 <code>import</code> 声明的数量减少。</p>
<p>如果把整个演讲概括一下，大概就是：<strong>能让你将 SOLID 应用到 Go 中就是接口（interfaces）。</strong></p>
<p>因为接口让我们 Go 开发者描述了我们提供包是做什么的，而不是如何实现的。换个说法就是「解耦」，这确实是我们的目标，因为解耦的软件修改起来更容易。</p>
<p>正如 Sandi Metz 提到的那样：</p>
<blockquote>
<p>Design is the art of arranging code that needs to work  <strong>today</strong>, and to be easy to change <strong>forever</strong>. – Sandi Metz</p>
</blockquote>
<p>因为如果 Go 想要成为公司长期投资的编程语言，作为 Go 程序的维护者，是否能对代码进行轻易地修改，是他们做出决定的关键因素。</p>
<h2 id="尾声">尾声</h2>
<p>最后，让我们回到演讲开始是，我提出的问题：这个世界上有多少个 Go 开发者？我的回答是：</p>
<blockquote>
<p>By 2020, there will be 500,000 Go developers. -me</p>
</blockquote>
<p>五十万 Go 开发者会做什么？显然，他们会写好多 Go 代码，不过实话实说，并不是所有的都是好的代码，其中一些可能会很糟糕。</p>
<p>请原谅我，我这样说并非出于残忍，但是，在场的各位当中，你们从其他语言转向 Go 的时候，你们原先的经验就是这个预言实现的一个因素之一。</p>
<blockquote>
<p>Within C++, there is a much smaller and cleaner language struggling to get out. – Bjarne Stroustrup, The Design and Evolution of C++</p>
</blockquote>
<p>对于所有 Go 开发者，让我们的语言更成功的机会来自于我们集体的能力，我们需要确保别人在谈论 Go 时像取笑如今的 C++ 那样的情况发生。</p>
<p>那些嘲弄其他语言的故事是膨胀的、冗余的和复杂的，也许有一天就会轮到 Go，我不想看到这样的事情发生，所以我有一个请求。</p>
<p>我们 Go 开发者应该多谈论设计而非框架，我们更应该关注重用带来的代价，而非性能带来的代价。</p>
<p>我希望看到是今天人们谈论关于如何使用编程语言，无论是设计解决方案还是解决实际问题的选择或局限。</p>
<p>我希望听到的是人们谈论如何通过精心设计、解耦、重用以及适应变化的方式来设计 Go 语言程序。</p>
<h2 id="最后一点">最后一点</h2>
<p>今天如此多的人来到这里听优秀的演讲是非常棒的事情，但是事实上，不管这样的会议规模如何增长，相较于不断增长的使用 Go 的开发者，我们只不过是很小一部分。</p>
<p>所以我们要告诉世界上其他的开发者好的软件应该要怎么写。让我们告诉他们怎么用 Go 来编写优秀的、可组合且易于改变的软件。请从你做起。</p>
<p>我希望你开始谈论设计，也许是我今天在这里提及的，但更希望是你自己研究之后应用到你自己项目中的观点。我希望你去做以下几点：</p>
<ul>
<li>写一篇博文</li>
<li>开班来讲解你们做的事情</li>
<li>把你学习的东西写成一本书</li>
<li>来年回到这个会议，并分享你的成就</li>
</ul>
<p>因为通过这做些事情，我们 Go 开发者可以创建一个关心软件设计能够源远流长的社区文化。</p>
<p>感谢！🤠🤠🤠🤠🤠</p>
]]></content>
    </entry>
</feed>